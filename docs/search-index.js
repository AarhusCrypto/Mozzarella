var N = null;var searchIndex = {};
searchIndex["fancy_garbling"]={"doc":"","items":[[0,"circuit","fancy_garbling","DSL for creating circuits compatible with fancy-garbling in the old-fashioned way, where you create a circuit for a computation then garble it.",N,N],[3,"Ref","fancy_garbling::circuit","The index and modulus of a gate in a circuit.",N,N],[12,"ix","","",0,N],[3,"Circuit","","Static representation of the type of computation supported by fancy garbling.",N,N],[12,"gates","","",1,N],[12,"gate_moduli","","",1,N],[12,"garbler_input_refs","","",1,N],[12,"evaluator_input_refs","","",1,N],[12,"const_refs","","",1,N],[12,"output_refs","","",1,N],[12,"num_nonfree_gates","","",1,N],[3,"CircuitBuilder","","CircuitBuilder is used to build circuits.",N,N],[12,"circ","","",2,N],[4,"Gate","","The most basic types of computation supported by fancy garbling.",N,N],[13,"GarblerInput","","",3,N],[12,"id","fancy_garbling::circuit::Gate","",3,N],[13,"EvaluatorInput","fancy_garbling::circuit","",3,N],[12,"id","fancy_garbling::circuit::Gate","",3,N],[13,"Constant","fancy_garbling::circuit","",3,N],[12,"val","fancy_garbling::circuit::Gate","",3,N],[13,"Add","fancy_garbling::circuit","",3,N],[12,"xref","fancy_garbling::circuit::Gate","",3,N],[12,"yref","","",3,N],[13,"Sub","fancy_garbling::circuit","",3,N],[12,"xref","fancy_garbling::circuit::Gate","",3,N],[12,"yref","","",3,N],[13,"Cmul","fancy_garbling::circuit","",3,N],[12,"xref","fancy_garbling::circuit::Gate","",3,N],[12,"c","","",3,N],[13,"Mul","fancy_garbling::circuit","",3,N],[12,"xref","fancy_garbling::circuit::Gate","",3,N],[12,"yref","","",3,N],[12,"id","","",3,N],[13,"Proj","fancy_garbling::circuit","",3,N],[12,"xref","fancy_garbling::circuit::Gate","",3,N],[12,"tt","","",3,N],[12,"id","","",3,N],[11,"eval","fancy_garbling::circuit","",1,N],[11,"num_garbler_inputs","","",1,[[["self"]],["usize"]]],[11,"num_evaluator_inputs","","",1,[[["self"]],["usize"]]],[11,"noutputs","","",1,[[["self"]],["usize"]]],[11,"modulus","","",1,[[["self"],["usize"]],["u16"]]],[11,"garbler_input_mod","","",1,[[["self"],["usize"]],["u16"]]],[11,"evaluator_input_mod","","",1,[[["self"],["usize"]],["u16"]]],[11,"print_info","","",1,[[["self"]]]],[11,"to_file","","",1,[[["self"],["str"]],["result",["error"]]]],[11,"from_file","","",1,[[["str"]],["result",["circuit","error"]]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"from_str","","",1,[[["str"]],["result",["circuit","error"]]]],[11,"new","","",2,[[],["self"]]],[11,"modulus","","",2,[[["self"],["ref"]],["u16"]]],[11,"finish","","",2,[[["self"]],["circuit"]]],[11,"borrow_circ","","",2,[[["self"]],["circuit"]]],[0,"garble","fancy_garbling","Structs and functions for creating, streaming, and evaluating garbled circuits.",N,N],[3,"Garbler","fancy_garbling::garble","Streams garbled circuit ciphertexts through a callback.",N,N],[3,"Evaluator","","Streaming evaluator using a callback to recieve ciphertexts as needed.",N,N],[3,"GarbledCircuit","","Static evaluator for a circuit, created by the `garble` function.",N,N],[3,"Encoder","","Encode inputs statically.",N,N],[3,"Decoder","","Decode outputs.",N,N],[4,"Message","","The outputs that can be emitted during streaming of a garbling.",N,N],[13,"GarblerInputZero","","Zero wire and delta for one of the garbler's inputs.",4,N],[12,"zero","fancy_garbling::garble::Message","",4,N],[12,"delta","","",4,N],[13,"EvaluatorInputZero","fancy_garbling::garble","Zero wire and delta for one of the evaluator's inputs.",4,N],[12,"zero","fancy_garbling::garble::Message","",4,N],[12,"delta","","",4,N],[13,"GarblerInput","fancy_garbling::garble","Encoded input for one of the garbler's inputs.",4,N],[13,"EvaluatorInput","","Encoded input for one of the evaluator's inputs.",4,N],[13,"Constant","","Constant wire carrying the value.",4,N],[12,"value","fancy_garbling::garble::Message","",4,N],[12,"wire","","",4,N],[13,"GarbledGate","fancy_garbling::garble","Garbled gate emitted by a projection or multiplication.",4,N],[13,"OutputCiphertext","","Output decoding information.",4,N],[5,"garble_iter","","Create an iterator over the messages produced by fancy garbling.",N,N],[5,"garble","","Garble a circuit without streaming.",N,N],[6,"GarbledGate","","The ciphertext created by a garbled gate.",N,N],[6,"OutputCiphertext","","Ciphertext created by the garbler for output gates.",N,N],[11,"to_bytes","","",4,[[["self"]],["vec",["u8"]]]],[11,"from_bytes","","",4,N],[11,"new","","Create a new garbler.",5,[[["fnmut"]],["garbler"]]],[11,"new","","Create a new Evaluator.",6,[[["fnmut"]],["evaluator"]]],[11,"decode_output","","Decode the output recieved during the Fancy computation.",6,[[["self"]],["vec",["u16"]]]],[11,"size","","",7,[[["self"]],["usize"]]],[11,"eval","","",7,N],[11,"to_bytes","","",7,[[["self"]],["vec",["u8"]]]],[11,"from_bytes","","",7,N],[11,"num_garbler_inputs","","",8,[[["self"]],["usize"]]],[11,"num_evaluator_inputs","","",8,[[["self"]],["usize"]]],[11,"encode_garbler_input","","",8,[[["self"],["u16"],["usize"]],["wire"]]],[11,"encode_evaluator_input","","",8,[[["self"],["u16"],["usize"]],["wire"]]],[11,"encode_garbler_inputs","","",8,N],[11,"encode_evaluator_inputs","","",8,N],[11,"to_bytes","","",8,[[["self"]],["vec",["u8"]]]],[11,"from_bytes","","",8,N],[11,"new","","",9,[[["vec",["vec"]]],["self"]]],[11,"decode","","",9,N],[11,"to_bytes","","",9,[[["self"]],["vec",["u8"]]]],[11,"from_bytes","","",9,N],[0,"wire","fancy_garbling","Low-level operations on wirelabels, the basic building block of garbled circuits.",N,N],[4,"Wire","fancy_garbling::wire","",N,N],[13,"Mod2","","",10,N],[12,"val","fancy_garbling::wire::Wire","",10,N],[13,"ModN","fancy_garbling::wire","",10,N],[12,"q","fancy_garbling::wire::Wire","",10,N],[12,"ds","","",10,N],[5,"wires_to_bytes","fancy_garbling::wire","",N,N],[5,"wires_from_bytes","","",N,N],[11,"digits","","",10,[[["self"]],["vec",["u16"]]]],[11,"from_u128","","",10,[[["u128"],["u16"]],["self"]]],[11,"as_u128","","",10,[[["self"]],["u128"]]],[11,"zero","","",10,[[["u16"]],["self"]]],[11,"set","","",10,[[["self"],["wire"]]]],[11,"set_zero","","",10,[[["self"]]]],[11,"rand_delta","","",10,[[["r"],["u16"]],["self"]]],[11,"color","","",10,[[["self"]],["u16"]]],[11,"plus","","",10,[[["self"],["self"]],["self"]]],[11,"plus_eq","","",10,[[["self"],["wire"]]]],[11,"cmul","","",10,[[["self"],["u16"]],["self"]]],[11,"cmul_eq","","",10,[[["self"],["u16"]]]],[11,"negate","","",10,[[["self"]],["self"]]],[11,"negate_eq","","",10,[[["self"]]]],[11,"minus","","",10,[[["self"],["wire"]],["wire"]]],[11,"minus_eq","","",10,[[["self"],["wire"]]]],[11,"rand","","",10,[[["r"],["u16"]],["wire"]]],[11,"hash","","",10,[[["self"],["u128"]],["u128"]]],[11,"hashback","","",10,[[["self"],["u128"],["u16"]],["wire"]]],[11,"hash2","","",10,[[["self"],["wire"],["u128"]],["u128"]]],[11,"hashback2","","",10,[[["self"],["wire"],["u128"],["u16"]],["wire"]]],[0,"util","fancy_garbling","Tools useful for interacting with `fancy-garbling`.",N,N],[5,"base_q_add","fancy_garbling::util","Add two base q numbers together.",N,N],[5,"base_q_add_eq","","Add a base q number into the first one.",N,N],[5,"as_base_q","","Convert a u128 into base q.",N,[[["u128"],["u16"],["usize"]],["vec",["u16"]]]],[5,"digits_per_u128","","Determine how many mod q digits fit into a u128.",N,[[["u16"]],["usize"]]],[5,"as_base_q_u128","","Convert a u128 into base q.",N,[[["u128"],["u16"]],["vec",["u16"]]]],[5,"as_mixed_radix","","Convert a u128 into mixed radix form with the provided radii.",N,N],[5,"from_base_q","","Convert little-endian base q digits into u128.",N,N],[5,"from_mixed_radix","","Convert little-endian mixed radix digits into u128.",N,N],[5,"u128_to_bits","","Get the bits of a u128 encoded in 128 u16s, which is convenient for the rest of the library, which uses u16 as the base digit type in Wire.",N,[[["u128"],["usize"]],["vec",["u16"]]]],[5,"u128_from_bits","","Convert into a u128 from the \"bits\" as u16. Assumes each \"bit\" is 0 or 1.",N,N],[5,"u128_to_bytes","","Convert a u128 into bytes.",N,N],[5,"bytes_to_u128","","Convert bytes to u128.",N,N],[5,"factor","","Factor using the primes in the global `PRIMES` array. Fancy garbling only supports composites with small prime factors.",N,[[["u128"]],["vec",["u16"]]]],[5,"crt","","Compute the CRT representation of x with respect to the primes ps.",N,N],[5,"crt_factor","","Compute the CRT representation of x with respect to the factorization of q.",N,[[["u128"],["u128"]],["vec",["u16"]]]],[5,"crt_inv","","Compute the value x given a list of CRT primes and residues.",N,N],[5,"crt_inv_factor","","Compute the value x given a composite CRT modulus.",N,N],[5,"inv_ref","","Generic algorithm to invert inp_a mod inp_b. As ref so as to support BigInts without copying.",N,[[["t"],["t"]],["t"]]],[5,"inv","","Invert a mod m.",N,[[["t"],["t"]],["t"]]],[5,"modulus_with_width","","Generate a CRT modulus that support at least n-bit integers, using the built-in PRIMES.",N,[[["u32"]],["u128"]]],[5,"base_modulus_with_width","","Generate a CRT modulus that support at least n-bit integers, using provided primes.",N,N],[5,"modulus_with_width_skip2","","Generate a CRT modulus that support at least n-bit integers, using the built-in PRIMES_SKIP_2 (does not include 2 as a factor).",N,[[["u32"]],["u128"]]],[5,"product","","Compute the product of some u16s as a u128.",N,N],[5,"powm","","Raise a u16 to a power mod some value.",N,[[["u16"],["u16"],["u16"]],["u16"]]],[5,"is_power_of_2","","Returns true if x is a power of 2. Delightfully generic.",N,[[["i"]],["bool"]]],[17,"NPRIMES","","Number of primes supported by our library.",N,N],[17,"PRIMES","","Primes used in fancy garbling.",N,N],[17,"PRIMES_SKIP_2","","Primes skipping the modulus 2, which allows certain gadgets.",N,N],[8,"RngExt","","Extra Rng functionality, useful for `fancy-garbling`.",N,N],[11,"gen_bool","","",11,[[["self"]],["bool"]]],[11,"gen_u16","","",11,[[["self"]],["u16"]]],[11,"gen_u32","","",11,[[["self"]],["u32"]]],[11,"gen_u64","","",11,[[["self"]],["u16"]]],[11,"gen_usize","","",11,[[["self"]],["usize"]]],[11,"gen_u128","","",11,[[["self"]],["u128"]]],[11,"gen_usable_u128","","",11,[[["self"],["u16"]],["u128"]]],[11,"gen_prime","","",11,[[["self"]],["u16"]]],[11,"gen_modulus","","",11,[[["self"]],["u16"]]],[11,"gen_usable_composite_modulus","","",11,[[["self"]],["u128"]]],[11,"gen_usable_factors","","",11,[[["self"]],["vec",["u16"]]]],[0,"aes","fancy_garbling","Wrapper for `aesni` with constant key for use as a hash function.",N,N],[3,"Aes","fancy_garbling::aes","",N,N],[17,"AES","","",N,N],[11,"new","","",12,[[["u128"]],["self"]]],[11,"from_bytes","","",12,N],[11,"hash","","",12,[[["self"],["u128"],["u128"]],["u128"]]],[11,"hash2","","",12,[[["self"],["u128"],["u128"],["u128"]],["u128"]]],[11,"eval_u128","","",12,[[["self"],["u128"]],["u128"]]],[11,"eval","","",12,N],[0,"fancy","fancy_garbling","The `Fancy` trait represents the kinds of computations possible in `fancy-garbling`.",N,N],[3,"Bundle","fancy_garbling::fancy","A collection of wires, useful for the garbled gadgets defined by `BundleGadgets`.",N,N],[8,"HasModulus","","An object that knows its own modulus.",N,N],[10,"modulus","","The modulus of the wire.",13,[[["self"]],["u16"]]],[8,"Fancy","","DSL for the basic computations supported by fancy-garbling.",N,N],[16,"Item","","The underlying wire datatype created by an object implementing `Fancy`.",14,N],[10,"garbler_input","","Create an input for the garbler with modulus `q`.",14,N],[10,"evaluator_input","","Create an input for the evaluator with modulus `q`.",14,N],[10,"constant","","Create a constant `x` with modulus `q`.",14,N],[10,"add","","Add `x` and `y`.",14,N],[10,"sub","","Subtract `x` and `y`.",14,N],[10,"cmul","","Multiply `x` times the constant `c`.",14,N],[10,"mul","","Multiply `x` and `y`.",14,N],[10,"proj","","Project `x` according to the truth table `tt`. Resulting wire has modulus `q`.",14,N],[10,"output","","Process this wire as output.",14,N],[11,"garbler_inputs","","Create `n` garbler inputs with modulus `q`.",14,[[["self"],["u16"],["usize"]],["vec"]]],[11,"evaluator_inputs","","Create `n` evaluator inputs with modulus `q`.",14,[[["self"],["u16"],["usize"]],["vec"]]],[11,"add_many","","Sum up a slice of wires.",14,N],[11,"xor","","Xor is just addition, with the requirement that `x` and `y` are mod 2.",14,N],[11,"negate","","Negate by xoring `x` with `1`.",14,N],[11,"and","","And is just multiplication, with the requirement that `x` and `y` are mod 2.",14,N],[11,"or","","Or uses Demorgan's Rule implemented with multiplication and negation.",14,N],[11,"and_many","","Returns 1 if all wires equal 1.",14,N],[11,"or_many","","Returns 1 if any wire equals 1.",14,N],[11,"mod_change","","Change the modulus of `x` to `to_modulus` using a projection gate.",14,N],[11,"outputs","","",14,N],[8,"BundleGadgets","","Extension trait for `Fancy` providing advanced gadgets based on bundles of wires.",N,N],[11,"garbler_input_bundle","","Crate an input bundle for the garbler using moduli `ps`.",15,N],[11,"evaluator_input_bundle","","Crate an input bundle for the evaluator using moduli `ps`.",15,N],[11,"garbler_input_bundle_crt","","Crate an input bundle for the garbler using composite CRT modulus `q`.",15,[[["self"],["u128"]],["bundle"]]],[11,"evaluator_input_bundle_crt","","Crate an input bundle for the evaluator using composite CRT modulus `q`.",15,[[["self"],["u128"]],["bundle"]]],[11,"constant_bundle","","Creates a bundle of constant wires using moduli `ps`.",15,N],[11,"constant_bundle_crt","","Creates a bundle of constant wires for the CRT representation of `x` under composite modulus `q`.",15,[[["self"],["u128"],["u128"]],["bundle"]]],[11,"garbler_input_bundles","","Create `n` garbler input bundles, using moduli `ps`.",15,N],[11,"evaluator_input_bundles","","Create `n` evaluator input bundles, using moduli `ps`.",15,N],[11,"garbler_input_bundles_crt","","Create `n` garbler input bundles, under composite CRT modulus `q`.",15,[[["self"],["u128"],["usize"]],["vec",["bundle"]]]],[11,"evaluator_input_bundles_crt","","Create `n` evaluator input bundles, under composite CRT modulus `q`.",15,[[["self"],["u128"],["usize"]],["vec",["bundle"]]]],[11,"output_bundle","","Output the wires that make up a bundle.",15,[[["self"],["bundle"]]]],[11,"add_bundles","","Add two wire bundles, residue by residue.",15,[[["self"],["bundle"],["bundle"]],["bundle"]]],[11,"sub_bundles","","Subtract two wire bundles, residue by residue.",15,[[["self"],["bundle"],["bundle"]],["bundle"]]],[11,"cmul_bundle","","Multiplies each wire in `x` by the corresponding residue of `c`.",15,[[["self"],["bundle"],["u128"]],["bundle"]]],[11,"mul_bundles","","Multiply `x` with `y`.",15,[[["self"],["bundle"],["bundle"]],["bundle"]]],[11,"cdiv_bundle","","Divide `x` by the constant `c`. Somewhat finicky, please test. I believe that it requires that `c` is coprime with all moduli.",15,[[["self"],["bundle"],["u16"]],["bundle"]]],[11,"cexp_bundle","","Exponentiate `x` by the constant `c`.",15,[[["self"],["bundle"],["u16"]],["bundle"]]],[11,"rem_bundle","","Compute the remainder with respect to modulus `p`.",15,[[["self"],["bundle"],["u16"]],["bundle"]]],[11,"eq_bundles","","Compute `x == y`. Returns a wire encoding the result mod 2.",15,N],[11,"mixed_radix_addition","","Mixed radix addition.",15,N],[11,"fractional_mixed_radix","","Helper function for advanced gadgets, returns the fractional part of `X/M` where `M=product(ms)`.",15,N],[11,"relu","","Compute `max(x,0)`, using potentially approximate factors of `M`.",15,N],[11,"exact_relu","","Compute `max(x,0)`.",15,[[["self"],["bundle"]],["bundle"]]],[11,"sign","","Return 0 if `x` is positive and 1 if `x` is negative. Potentially approximate depending on `factors_of_m`.",15,N],[11,"exact_sign","","Return 0 if `x` is positive and 1 if `x` is negative.",15,N],[11,"sgn","","Return `if x >= 0 then 1 else -1`, where `-1` is interpreted as `Q-1`. Potentially approximate depending on `factors_of_m`.",15,N],[11,"exact_sgn","","Return `if x >= 0 then 1 else -1`, where `-1` is interpreted as `Q-1`.",15,[[["self"],["bundle"]],["bundle"]]],[11,"exact_lt","","Returns 1 if `x < y`",15,N],[11,"max","","Compute the maximum bundle in `xs`.",15,N],[11,"moduli","","Return the moduli of all the wires in the bundle.",16,[[["self"]],["vec",["u16"]]]],[11,"wires","","Extract the wires from this bundle.",16,N],[11,"from","fancy_garbling::circuit","",0,[[["t"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"from","","",1,[[["t"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"from","","",3,[[["t"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"from","fancy_garbling::garble","",5,[[["t"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_string","","",4,[[["self"]],["string"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"from","fancy_garbling::wire","",10,[[["t"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,N],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"from","fancy_garbling::aes","",12,[[["t"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,N],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"from","fancy_garbling::fancy","",16,[[["t"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,N],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"modulus","fancy_garbling::circuit","",0,[[["self"]],["u16"]]],[11,"modulus","fancy_garbling::wire","",10,[[["self"]],["u16"]]],[11,"garbler_input","fancy_garbling::circuit","",2,[[["self"],["u16"]],["ref"]]],[11,"evaluator_input","","",2,[[["self"],["u16"]],["ref"]]],[11,"constant","","",2,[[["self"],["u16"],["u16"]],["ref"]]],[11,"add","","",2,[[["self"],["ref"],["ref"]],["ref"]]],[11,"sub","","",2,[[["self"],["ref"],["ref"]],["ref"]]],[11,"cmul","","",2,[[["self"],["ref"],["u16"]],["ref"]]],[11,"proj","","",2,N],[11,"mul","","",2,[[["self"],["ref"],["ref"]],["ref"]]],[11,"output","","",2,[[["self"],["ref"]]]],[11,"garbler_input","fancy_garbling::garble","",5,[[["self"],["u16"]],["wire"]]],[11,"evaluator_input","","",5,[[["self"],["u16"]],["wire"]]],[11,"constant","","",5,[[["self"],["u16"],["u16"]],["wire"]]],[11,"add","","",5,[[["self"],["wire"],["wire"]],["wire"]]],[11,"sub","","",5,[[["self"],["wire"],["wire"]],["wire"]]],[11,"cmul","","",5,[[["self"],["wire"],["u16"]],["wire"]]],[11,"mul","","",5,[[["self"],["wire"],["wire"]],["wire"]]],[11,"proj","","",5,N],[11,"output","","",5,[[["self"],["wire"]]]],[11,"garbler_input","","",6,[[["self"],["u16"]],["wire"]]],[11,"evaluator_input","","",6,[[["self"],["u16"]],["wire"]]],[11,"constant","","",6,[[["self"],["u16"],["u16"]],["wire"]]],[11,"add","","",6,[[["self"],["wire"],["wire"]],["wire"]]],[11,"sub","","",6,[[["self"],["wire"],["wire"]],["wire"]]],[11,"cmul","","",6,[[["self"],["wire"],["u16"]],["wire"]]],[11,"mul","","",6,[[["self"],["wire"],["wire"]],["wire"]]],[11,"proj","","",6,N],[11,"output","","",6,[[["self"],["wire"]]]],[11,"clone","fancy_garbling::circuit","",0,[[["self"]],["ref"]]],[11,"clone","","",1,[[["self"]],["circuit"]]],[11,"clone","","",3,[[["self"]],["gate"]]],[11,"clone","fancy_garbling::wire","",10,[[["self"]],["wire"]]],[11,"clone","fancy_garbling::aes","",12,[[["self"]],["self"]]],[11,"clone","fancy_garbling::fancy","",16,[[["self"]],["bundle"]]],[11,"partial_cmp","fancy_garbling::wire","",10,[[["self"],["wire"]],["option",["ordering"]]]],[11,"lt","","",10,[[["self"],["wire"]],["bool"]]],[11,"le","","",10,[[["self"],["wire"]],["bool"]]],[11,"gt","","",10,[[["self"],["wire"]],["bool"]]],[11,"ge","","",10,[[["self"],["wire"]],["bool"]]],[11,"eq","fancy_garbling::circuit","",0,[[["self"],["ref"]],["bool"]]],[11,"ne","","",0,[[["self"],["ref"]],["bool"]]],[11,"eq","","",1,[[["self"],["circuit"]],["bool"]]],[11,"ne","","",1,[[["self"],["circuit"]],["bool"]]],[11,"eq","","",3,[[["self"],["gate"]],["bool"]]],[11,"ne","","",3,[[["self"],["gate"]],["bool"]]],[11,"eq","fancy_garbling::garble","",7,[[["self"],["garbledcircuit"]],["bool"]]],[11,"ne","","",7,[[["self"],["garbledcircuit"]],["bool"]]],[11,"eq","","",8,[[["self"],["encoder"]],["bool"]]],[11,"ne","","",8,[[["self"],["encoder"]],["bool"]]],[11,"eq","","",9,[[["self"],["decoder"]],["bool"]]],[11,"ne","","",9,[[["self"],["decoder"]],["bool"]]],[11,"eq","fancy_garbling::wire","",10,[[["self"],["wire"]],["bool"]]],[11,"ne","","",10,[[["self"],["wire"]],["bool"]]],[11,"fmt","fancy_garbling::garble","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling::circuit","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling::garble","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling::wire","",10,[[["self"],["formatter"]],["result"]]],[11,"serialize","fancy_garbling::circuit","",0,[[["self"],["__s"]],["result"]]],[11,"serialize","","",1,[[["self"],["__s"]],["result"]]],[11,"serialize","","",3,[[["self"],["__s"]],["result"]]],[11,"serialize","fancy_garbling::garble","",4,[[["self"],["__s"]],["result"]]],[11,"serialize","","",7,[[["self"],["__s"]],["result"]]],[11,"serialize","","",8,[[["self"],["__s"]],["result"]]],[11,"serialize","","",9,[[["self"],["__s"]],["result"]]],[11,"serialize","fancy_garbling::wire","",10,[[["self"],["__s"]],["result"]]],[11,"deserialize","fancy_garbling::circuit","",0,[[["__d"]],["result"]]],[11,"deserialize","","",1,[[["__d"]],["result"]]],[11,"deserialize","","",3,[[["__d"]],["result"]]],[11,"deserialize","fancy_garbling::garble","",4,[[["__d"]],["result"]]],[11,"deserialize","","",7,[[["__d"]],["result"]]],[11,"deserialize","","",8,[[["__d"]],["result"]]],[11,"deserialize","","",9,[[["__d"]],["result"]]],[11,"deserialize","fancy_garbling::wire","",10,[[["__d"]],["result"]]]],"paths":[[3,"Ref"],[3,"Circuit"],[3,"CircuitBuilder"],[4,"Gate"],[4,"Message"],[3,"Garbler"],[3,"Evaluator"],[3,"GarbledCircuit"],[3,"Encoder"],[3,"Decoder"],[4,"Wire"],[8,"RngExt"],[3,"Aes"],[8,"HasModulus"],[8,"Fancy"],[8,"BundleGadgets"],[3,"Bundle"]]};
initSearch(searchIndex);
