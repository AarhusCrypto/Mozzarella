var N = null;var searchIndex = {};
searchIndex["fancy_garbling"]={"doc":"","items":[[0,"circuit","fancy_garbling","DSL for creating circuits compatible with fancy-garbling in the old-fashioned way, where you create a circuit for a computation then garble it.",N,N],[3,"Ref","fancy_garbling::circuit","The index and modulus of a gate in a circuit.",N,N],[12,"ix","","",0,N],[3,"Circuit","","Static representation of the type of computation supported by fancy garbling.",N,N],[12,"gates","","",1,N],[12,"gate_moduli","","",1,N],[12,"garbler_input_refs","","",1,N],[12,"evaluator_input_refs","","",1,N],[12,"const_refs","","",1,N],[12,"output_refs","","",1,N],[12,"num_nonfree_gates","","",1,N],[3,"CircuitBuilder","","CircuitBuilder is used to build circuits.",N,N],[12,"circ","","",2,N],[4,"Gate","","The most basic types of computation supported by fancy garbling.",N,N],[13,"GarblerInput","","",3,N],[12,"id","fancy_garbling::circuit::Gate","",3,N],[13,"EvaluatorInput","fancy_garbling::circuit","",3,N],[12,"id","fancy_garbling::circuit::Gate","",3,N],[13,"Constant","fancy_garbling::circuit","",3,N],[12,"val","fancy_garbling::circuit::Gate","",3,N],[13,"Add","fancy_garbling::circuit","",3,N],[12,"xref","fancy_garbling::circuit::Gate","",3,N],[12,"yref","","",3,N],[13,"Sub","fancy_garbling::circuit","",3,N],[12,"xref","fancy_garbling::circuit::Gate","",3,N],[12,"yref","","",3,N],[13,"Cmul","fancy_garbling::circuit","",3,N],[12,"xref","fancy_garbling::circuit::Gate","",3,N],[12,"c","","",3,N],[13,"Mul","fancy_garbling::circuit","",3,N],[12,"xref","fancy_garbling::circuit::Gate","",3,N],[12,"yref","","",3,N],[12,"id","","",3,N],[13,"Proj","fancy_garbling::circuit","",3,N],[12,"xref","fancy_garbling::circuit::Gate","",3,N],[12,"tt","","",3,N],[12,"id","","",3,N],[11,"eval","fancy_garbling::circuit","",1,N],[11,"num_garbler_inputs","","",1,[[["self"]],["usize"]]],[11,"num_evaluator_inputs","","",1,[[["self"]],["usize"]]],[11,"noutputs","","",1,[[["self"]],["usize"]]],[11,"modulus","","",1,[[["self"],["usize"]],["u16"]]],[11,"garbler_input_mod","","",1,[[["self"],["usize"]],["u16"]]],[11,"evaluator_input_mod","","",1,[[["self"],["usize"]],["u16"]]],[11,"print_info","","",1,[[["self"]]]],[11,"to_file","","",1,[[["self"],["str"]],["result",["error"]]]],[11,"from_file","","",1,[[["str"]],["result",["circuit","error"]]]],[11,"to_string","","",1,[[["self"]],["string"]]],[11,"from_str","","",1,[[["str"]],["result",["circuit","error"]]]],[11,"new","","",2,[[],["self"]]],[11,"modulus","","",2,[[["self"],["ref"]],["u16"]]],[11,"finish","","",2,[[["self"]],["circuit"]]],[11,"borrow_circ","","",2,[[["self"]],["circuit"]]],[0,"garble","fancy_garbling","Structs and functions for creating, streaming, and evaluating garbled circuits.",N,N],[3,"Garbler","fancy_garbling::garble","Streams garbled circuit ciphertexts through a callback.",N,N],[3,"Evaluator","","Streaming evaluator using a callback to recieve ciphertexts as needed.",N,N],[3,"GarbledCircuit","","Static evaluator for a circuit, created by the `garble` function.",N,N],[3,"Encoder","","Encode inputs statically.",N,N],[3,"Decoder","","Decode outputs.",N,N],[4,"Message","","The outputs that can be emitted during streaming of a garbling.",N,N],[13,"UnencodedGarblerInput","","Zero wire and delta for one of the garbler's inputs.",4,N],[12,"zero","fancy_garbling::garble::Message","",4,N],[12,"delta","","",4,N],[13,"UnencodedEvaluatorInput","fancy_garbling::garble","Zero wire and delta for one of the evaluator's inputs.",4,N],[12,"zero","fancy_garbling::garble::Message","",4,N],[12,"delta","","",4,N],[13,"GarblerInput","fancy_garbling::garble","Encoded input for one of the garbler's inputs.",4,N],[13,"EvaluatorInput","","Encoded input for one of the evaluator's inputs.",4,N],[13,"Constant","","Constant wire carrying the value.",4,N],[12,"value","fancy_garbling::garble::Message","",4,N],[12,"wire","","",4,N],[13,"GarbledGate","fancy_garbling::garble","Garbled gate emitted by a projection or multiplication.",4,N],[13,"OutputCiphertext","","Output decoding information.",4,N],[5,"garble_iter","","Create an iterator over the messages produced by fancy garbling.",N,N],[5,"garble","","Garble a circuit without streaming.",N,N],[5,"bench","","Run benchmark garbling and streaming on the function. Funky function arguments to work around the pesky borrow checker.",N,[[["usize"],["box",["fn"]],["box",["fn"]]]]],[6,"GarbledGate","","The ciphertext created by a garbled gate.",N,N],[6,"OutputCiphertext","","Ciphertext created by the garbler for output gates.",N,N],[11,"to_bytes","","",4,[[["self"]],["vec",["u8"]]]],[11,"from_bytes","","",4,N],[11,"new","","Create a new garbler.",5,[[["box",["fnmut"]]],["garbler"]]],[11,"new","","Create a new Evaluator.",6,[[["fnmut"]],["evaluator"]]],[11,"decode_output","","Decode the output recieved during the Fancy computation.",6,[[["self"]],["vec",["u16"]]]],[11,"size","","",7,[[["self"]],["usize"]]],[11,"eval","","",7,N],[11,"to_bytes","","",7,[[["self"]],["vec",["u8"]]]],[11,"from_bytes","","",7,N],[11,"num_garbler_inputs","","",8,[[["self"]],["usize"]]],[11,"num_evaluator_inputs","","",8,[[["self"]],["usize"]]],[11,"encode_garbler_input","","",8,[[["self"],["u16"],["usize"]],["wire"]]],[11,"encode_evaluator_input","","",8,[[["self"],["u16"],["usize"]],["wire"]]],[11,"encode_garbler_inputs","","",8,N],[11,"encode_evaluator_inputs","","",8,N],[11,"to_bytes","","",8,[[["self"]],["vec",["u8"]]]],[11,"from_bytes","","",8,N],[11,"new","","",9,[[["vec",["vec"]]],["self"]]],[11,"decode","","",9,N],[11,"to_bytes","","",9,[[["self"]],["vec",["u8"]]]],[11,"from_bytes","","",9,N],[0,"wire","fancy_garbling","Low-level operations on wirelabels, the basic building block of garbled circuits.",N,N],[4,"Wire","fancy_garbling::wire","",N,N],[13,"Mod2","","",10,N],[12,"val","fancy_garbling::wire::Wire","",10,N],[13,"ModN","fancy_garbling::wire","",10,N],[12,"q","fancy_garbling::wire::Wire","",10,N],[12,"ds","","",10,N],[5,"wires_to_bytes","fancy_garbling::wire","",N,N],[5,"wires_from_bytes","","",N,N],[11,"digits","","",10,[[["self"]],["vec",["u16"]]]],[11,"from_u128","","",10,[[["u128"],["u16"]],["self"]]],[11,"as_u128","","",10,[[["self"]],["u128"]]],[11,"zero","","",10,[[["u16"]],["self"]]],[11,"set","","",10,[[["self"],["wire"]]]],[11,"set_zero","","",10,[[["self"]]]],[11,"rand_delta","","",10,[[["r"],["u16"]],["self"]]],[11,"color","","",10,[[["self"]],["u16"]]],[11,"plus","","",10,[[["self"],["self"]],["self"]]],[11,"plus_eq","","",10,[[["self"],["wire"]]]],[11,"cmul","","",10,[[["self"],["u16"]],["self"]]],[11,"cmul_eq","","",10,[[["self"],["u16"]]]],[11,"negate","","",10,[[["self"]],["self"]]],[11,"negate_eq","","",10,[[["self"]]]],[11,"minus","","",10,[[["self"],["wire"]],["wire"]]],[11,"minus_eq","","",10,[[["self"],["wire"]]]],[11,"rand","","",10,[[["r"],["u16"]],["wire"]]],[11,"hash","","",10,[[["self"],["u128"]],["u128"]]],[11,"hashback","","",10,[[["self"],["u128"],["u16"]],["wire"]]],[11,"hash2","","",10,[[["self"],["wire"],["u128"]],["u128"]]],[11,"hashback2","","",10,[[["self"],["wire"],["u128"],["u16"]],["wire"]]],[0,"util","fancy_garbling","Tools useful for interacting with `fancy-garbling`.",N,N],[5,"base_q_add","fancy_garbling::util","Add two base q numbers together.",N,N],[5,"base_q_add_eq","","Add a base q number into the first one.",N,N],[5,"as_base_q","","Convert a u128 into base q.",N,[[["u128"],["u16"],["usize"]],["vec",["u16"]]]],[5,"digits_per_u128","","Determine how many mod q digits fit into a u128.",N,[[["u16"]],["usize"]]],[5,"as_base_q_u128","","Convert a u128 into base q.",N,[[["u128"],["u16"]],["vec",["u16"]]]],[5,"as_mixed_radix","","Convert a u128 into mixed radix form with the provided radii.",N,N],[5,"from_base_q","","Convert little-endian base q digits into u128.",N,N],[5,"from_mixed_radix","","Convert little-endian mixed radix digits into u128.",N,N],[5,"u128_to_bits","","Get the bits of a u128 encoded in 128 u16s, which is convenient for the rest of the library, which uses u16 as the base digit type in Wire.",N,[[["u128"],["usize"]],["vec",["u16"]]]],[5,"u128_from_bits","","Convert into a u128 from the \"bits\" as u16. Assumes each \"bit\" is 0 or 1.",N,N],[5,"u128_to_bytes","","Convert a u128 into bytes.",N,N],[5,"bytes_to_u128","","Convert bytes to u128.",N,N],[5,"factor","","Factor using the primes in the global `PRIMES` array. Fancy garbling only supports composites with small prime factors.",N,[[["u128"]],["vec",["u16"]]]],[5,"crt","","Compute the CRT representation of x with respect to the primes ps.",N,N],[5,"crt_factor","","Compute the CRT representation of x with respect to the factorization of q.",N,[[["u128"],["u128"]],["vec",["u16"]]]],[5,"crt_inv","","Compute the value x given a list of CRT primes and residues.",N,N],[5,"crt_inv_factor","","Compute the value x given a composite CRT modulus.",N,N],[5,"inv_ref","","Generic algorithm to invert inp_a mod inp_b. As ref so as to support BigInts without copying.",N,[[["t"],["t"]],["t"]]],[5,"inv","","Invert a mod m.",N,[[["t"],["t"]],["t"]]],[5,"modulus_with_width","","Generate a CRT modulus that support at least n-bit integers, using the built-in PRIMES.",N,[[["u32"]],["u128"]]],[5,"primes_with_width","","Generate the factors of a CRT modulus that support at least n-bit integers, using the built-in PRIMES.",N,[[["u32"]],["vec",["u16"]]]],[5,"base_modulus_with_width","","Generate a CRT modulus that support at least n-bit integers, using provided primes.",N,N],[5,"base_primes_with_width","","Generate the factors of a CRT modulus that support at least n-bit integers, using provided primes.",N,N],[5,"modulus_with_width_skip2","","Generate a CRT modulus that support at least n-bit integers, using the built-in PRIMES_SKIP_2 (does not include 2 as a factor).",N,[[["u32"]],["u128"]]],[5,"product","","Compute the product of some u16s as a u128.",N,N],[5,"powm","","Raise a u16 to a power mod some value.",N,[[["u16"],["u16"],["u16"]],["u16"]]],[5,"is_power_of_2","","Returns true if x is a power of 2. Delightfully generic.",N,[[["i"]],["bool"]]],[17,"NPRIMES","","Number of primes supported by our library.",N,N],[17,"PRIMES","","Primes used in fancy garbling.",N,N],[17,"PRIMES_SKIP_2","","Primes skipping the modulus 2, which allows certain gadgets.",N,N],[8,"RngExt","","Extra Rng functionality, useful for `fancy-garbling`.",N,N],[11,"gen_bool","","",11,[[["self"]],["bool"]]],[11,"gen_u16","","",11,[[["self"]],["u16"]]],[11,"gen_u32","","",11,[[["self"]],["u32"]]],[11,"gen_u64","","",11,[[["self"]],["u16"]]],[11,"gen_usize","","",11,[[["self"]],["usize"]]],[11,"gen_u128","","",11,[[["self"]],["u128"]]],[11,"gen_usable_u128","","",11,[[["self"],["u16"]],["u128"]]],[11,"gen_prime","","",11,[[["self"]],["u16"]]],[11,"gen_modulus","","",11,[[["self"]],["u16"]]],[11,"gen_usable_composite_modulus","","",11,[[["self"]],["u128"]]],[11,"gen_usable_factors","","",11,[[["self"]],["vec",["u16"]]]],[0,"aes","fancy_garbling","Wrapper for `aesni` with constant key for use as a hash function.",N,N],[3,"Aes","fancy_garbling::aes","",N,N],[17,"AES","","",N,N],[11,"new","","",12,[[["u128"]],["self"]]],[11,"from_bytes","","",12,N],[11,"hash","","",12,[[["self"],["u128"],["u128"]],["u128"]]],[11,"hash2","","",12,[[["self"],["u128"],["u128"],["u128"]],["u128"]]],[11,"eval_u128","","",12,[[["self"],["u128"]],["u128"]]],[11,"eval","","",12,N],[0,"fancy","fancy_garbling","The `Fancy` trait represents the kinds of computations possible in `fancy-garbling`.",N,N],[3,"Bundle","fancy_garbling::fancy","A collection of wires, useful for the garbled gadgets defined by `BundleGadgets`.",N,N],[8,"HasModulus","","An object that knows its own modulus.",N,N],[10,"modulus","","The modulus of the wire.",13,[[["self"]],["u16"]]],[8,"Fancy","","DSL for the basic computations supported by fancy-garbling.",N,N],[16,"Item","","The underlying wire datatype created by an object implementing `Fancy`.",14,N],[10,"garbler_input","","Create an input for the garbler with modulus `q`.",14,N],[10,"evaluator_input","","Create an input for the evaluator with modulus `q`.",14,N],[10,"constant","","Create a constant `x` with modulus `q`.",14,N],[10,"add","","Add `x` and `y`.",14,N],[10,"sub","","Subtract `x` and `y`.",14,N],[10,"cmul","","Multiply `x` times the constant `c`.",14,N],[10,"mul","","Multiply `x` and `y`.",14,N],[10,"proj","","Project `x` according to the truth table `tt`. Resulting wire has modulus `q`.",14,N],[10,"output","","Process this wire as output.",14,N],[11,"garbler_inputs","","Create `n` garbler inputs with modulus `q`.",14,[[["self"],["u16"],["usize"]],["vec"]]],[11,"evaluator_inputs","","Create `n` evaluator inputs with modulus `q`.",14,[[["self"],["u16"],["usize"]],["vec"]]],[11,"add_many","","Sum up a slice of wires.",14,N],[11,"xor","","Xor is just addition, with the requirement that `x` and `y` are mod 2.",14,N],[11,"negate","","Negate by xoring `x` with `1`.",14,N],[11,"and","","And is just multiplication, with the requirement that `x` and `y` are mod 2.",14,N],[11,"or","","Or uses Demorgan's Rule implemented with multiplication and negation.",14,N],[11,"and_many","","Returns 1 if all wires equal 1.",14,N],[11,"or_many","","Returns 1 if any wire equals 1.",14,N],[11,"mod_change","","Change the modulus of `x` to `to_modulus` using a projection gate.",14,N],[11,"adder","","Binary adder. Returns the result and the carry.",14,N],[11,"mux","","If `x=0` return the constant `b1` else return `b2`. Folds constants if possible.",14,N],[11,"outputs","","Output a slice of wires.",14,N],[8,"BundleGadgets","","Extension trait for `Fancy` providing advanced gadgets based on bundles of wires.",N,N],[11,"garbler_input_bundle","","Crate an input bundle for the garbler using moduli `ps`.",15,N],[11,"evaluator_input_bundle","","Crate an input bundle for the evaluator using moduli `ps`.",15,N],[11,"garbler_input_bundle_crt","","Crate an input bundle for the garbler using composite CRT modulus `q`.",15,[[["self"],["u128"]],["bundle"]]],[11,"evaluator_input_bundle_crt","","Crate an input bundle for the evaluator using composite CRT modulus `q`.",15,[[["self"],["u128"]],["bundle"]]],[11,"garbler_input_bundle_binary","","Create an input bundle for the garbler using n base 2 inputs.",15,[[["self"],["usize"]],["bundle"]]],[11,"evaluator_input_bundle_binary","","Create an input bundle for the evaluator using n base 2 inputs.",15,[[["self"],["usize"]],["bundle"]]],[11,"constant_bundle","","Creates a bundle of constant wires using moduli `ps`.",15,N],[11,"constant_bundle_crt","","Creates a bundle of constant wires for the CRT representation of `x` under composite modulus `q`.",15,[[["self"],["u128"],["u128"]],["bundle"]]],[11,"garbler_input_bundles","","Create `n` garbler input bundles, using moduli `ps`.",15,N],[11,"evaluator_input_bundles","","Create `n` evaluator input bundles, using moduli `ps`.",15,N],[11,"garbler_input_bundles_crt","","Create `n` garbler input bundles, under composite CRT modulus `q`.",15,[[["self"],["u128"],["usize"]],["vec",["bundle"]]]],[11,"evaluator_input_bundles_crt","","Create `n` evaluator input bundles, under composite CRT modulus `q`.",15,[[["self"],["u128"],["usize"]],["vec",["bundle"]]]],[11,"output_bundle","","Output the wires that make up a bundle.",15,[[["self"],["bundle"]]]],[11,"add_bundles","","Add two wire bundles, residue by residue.",15,[[["self"],["bundle"],["bundle"]],["bundle"]]],[11,"sub_bundles","","Subtract two wire bundles, residue by residue.",15,[[["self"],["bundle"],["bundle"]],["bundle"]]],[11,"cmul_bundle","","Multiplies each wire in `x` by the corresponding residue of `c`.",15,[[["self"],["bundle"],["u128"]],["bundle"]]],[11,"mul_bundles","","Multiply `x` with `y`.",15,[[["self"],["bundle"],["bundle"]],["bundle"]]],[11,"cdiv_bundle","","Divide `x` by the constant `c`. Somewhat finicky, please test. I believe that it requires that `c` is coprime with all moduli.",15,[[["self"],["bundle"],["u16"]],["bundle"]]],[11,"cexp_bundle","","Exponentiate `x` by the constant `c`.",15,[[["self"],["bundle"],["u16"]],["bundle"]]],[11,"rem_bundle","","Compute the remainder with respect to modulus `p`.",15,[[["self"],["bundle"],["u16"]],["bundle"]]],[11,"eq_bundles","","Compute `x == y`. Returns a wire encoding the result mod 2.",15,N],[11,"mixed_radix_addition","","Mixed radix addition.",15,N],[11,"fractional_mixed_radix","","Helper function for advanced gadgets, returns the fractional part of `X/M` where `M=product(ms)`.",15,N],[11,"relu","","Compute `max(x,0)`, using potentially approximate factors of `M`.",15,N],[11,"exact_relu","","Compute `max(x,0)`.",15,[[["self"],["bundle"]],["bundle"]]],[11,"sign","","Return 0 if `x` is positive and 1 if `x` is negative. Potentially approximate depending on `factors_of_m`.",15,N],[11,"exact_sign","","Return 0 if `x` is positive and 1 if `x` is negative.",15,N],[11,"sgn","","Return `if x >= 0 then 1 else -1`, where `-1` is interpreted as `Q-1`. Potentially approximate depending on `factors_of_m`.",15,N],[11,"exact_sgn","","Return `if x >= 0 then 1 else -1`, where `-1` is interpreted as `Q-1`.",15,[[["self"],["bundle"]],["bundle"]]],[11,"exact_lt","","Returns 1 if `x < y`. Works on both CRT and binary bundles.",15,N],[11,"exact_geq","","Returns 1 if `x >= y`. Works on both CRT and binary bundles.",15,N],[11,"max","","Compute the maximum bundle in `xs`. Works on both CRT and binary bundles.",15,N],[11,"binary_addition","","Binary addition. Returns the result and the carry.",15,N],[11,"binary_addition_no_carry","","Binary addition. Avoids creating extra gates for the final carry.",15,[[["self"],["bundle"],["bundle"]],["bundle"]]],[11,"twos_complement","","Compute the twos complement of the input bundle (which must be base 2).",15,[[["self"],["bundle"]],["bundle"]]],[11,"binary_subtraction","","Subtract two binary bundles. Returns the result and whether it overflowed.",15,N],[11,"multiplex_constant_bits","","If `x=0` return `c1` as a bundle of constant bits, else return `c2`.",15,N],[11,"shift","","Shift residues, replacing them with zeros in the modulus of the last residue.",15,[[["self"],["bundle"],["usize"]],["bundle"]]],[11,"binary_cmul","","Write the constant in binary and that gives you the shift amounts, Eg.. 7x is 4x+2x+x.",15,[[["self"],["bundle"],["u128"],["usize"]],["bundle"]]],[11,"new","","Create a new bundle from some wires.",16,[[["vec"]],["bundle"]]],[11,"moduli","","Return the moduli of all the wires in the bundle.",16,[[["self"]],["vec",["u16"]]]],[11,"wires","","Extract the wires from this bundle.",16,N],[11,"size","","Get the number of wires in this bundle.",16,[[["self"]],["usize"]]],[11,"is_binary","","Whether this bundle only contains residues in mod 2.",16,[[["self"]],["bool"]]],[0,"dummy","fancy_garbling","Dummy implementation of Fancy.",N,N],[3,"Dummy","fancy_garbling::dummy","Simple struct that performs the fancy computation over u16.",N,N],[3,"DummyVal","","Wrapper around u16.",N,N],[11,"new","","Create a new Dummy.",17,N],[11,"get_output","","Get the output from the fancy computation.",17,[[["self"]],["vec",["u16"]]]],[0,"informer","fancy_garbling","Informer runs a fancy computation and learns information from it, like how many of what kind of inputs there are.",N,N],[3,"Informer","fancy_garbling::informer","Implements Fancy. Use to learn information about a fancy computation in a lightweight way.",N,N],[3,"InformerVal","","",N,N],[11,"new","","",18,[[],["informer"]]],[11,"print_info","","Print information about the fancy computation.",18,[[["self"]]]],[11,"num_garbler_inputs","","Number of garbler inputs in the fancy computation.",18,[[["self"]],["usize"]]],[11,"garbler_input_moduli","","Moduli of garbler inputs in the fancy computation.",18,[[["self"]],["vec",["u16"]]]],[11,"num_evaluator_inputs","","Number of evaluator inputs in the fancy computation.",18,[[["self"]],["usize"]]],[11,"evaluator_input_moduli","","Moduli of evaluator inputs in the fancy computation.",18,[[["self"]],["vec",["u16"]]]],[11,"num_consts","","Number of constants in the fancy computation. NOTE: does not reflect that constants will be reused by most implementors of Fancy.",18,[[["self"]],["usize"]]],[11,"num_outputs","","Number of outputs in the fancy computation.",18,[[["self"]],["usize"]]],[11,"num_output_ciphertexts","","Number of output ciphertexts.",18,[[["self"]],["usize"]]],[11,"num_adds","","Number of additions in the fancy computation.",18,[[["self"]],["usize"]]],[11,"num_subs","","Number of subtractions in the fancy computation.",18,[[["self"]],["usize"]]],[11,"num_cmuls","","Number of scalar multiplications in the fancy computation.",18,[[["self"]],["usize"]]],[11,"num_muls","","Number of multiplications in the fancy computation.",18,[[["self"]],["usize"]]],[11,"num_projs","","Number of projections in the fancy computation.",18,[[["self"]],["usize"]]],[11,"num_ciphertexts","","Number of ciphertexts in the fancy computation.",18,[[["self"]],["usize"]]],[11,"into","fancy_garbling::circuit","",0,[[["self"]],["u"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"into","","",2,[[["self"]],["u"]]],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"into","fancy_garbling::garble","",5,[[["self"]],["u"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"into","","",6,[[["self"]],["u"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_string","","",4,[[["self"]],["string"]]],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"into","fancy_garbling::wire","",10,[[["self"]],["u"]]],[11,"to_owned","","",10,[[["self"]],["t"]]],[11,"clone_into","","",10,N],[11,"from","","",10,[[["t"]],["t"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"into","fancy_garbling::aes","",12,[[["self"]],["u"]]],[11,"to_owned","","",12,[[["self"]],["t"]]],[11,"clone_into","","",12,N],[11,"from","","",12,[[["t"]],["t"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"into","fancy_garbling::fancy","",16,[[["self"]],["u"]]],[11,"to_owned","","",16,[[["self"]],["t"]]],[11,"clone_into","","",16,N],[11,"from","","",16,[[["t"]],["t"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"into","fancy_garbling::dummy","",17,[[["self"]],["u"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"into","","",19,[[["self"]],["u"]]],[11,"to_owned","","",19,[[["self"]],["t"]]],[11,"clone_into","","",19,N],[11,"from","","",19,[[["t"]],["t"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"into","fancy_garbling::informer","",18,[[["self"]],["u"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"into","","",20,[[["self"]],["u"]]],[11,"to_owned","","",20,[[["self"]],["t"]]],[11,"clone_into","","",20,N],[11,"from","","",20,[[["t"]],["t"]]],[11,"try_from","","",20,[[["u"]],["result"]]],[11,"borrow","","",20,[[["self"]],["t"]]],[11,"get_type_id","","",20,[[["self"]],["typeid"]]],[11,"try_into","","",20,[[["self"]],["result"]]],[11,"borrow_mut","","",20,[[["self"]],["t"]]],[11,"modulus","fancy_garbling::circuit","",0,[[["self"]],["u16"]]],[11,"modulus","fancy_garbling::wire","",10,[[["self"]],["u16"]]],[11,"modulus","fancy_garbling::dummy","",19,[[["self"]],["u16"]]],[11,"modulus","fancy_garbling::informer","",20,[[["self"]],["u16"]]],[11,"garbler_input","fancy_garbling::circuit","",2,[[["self"],["u16"]],["ref"]]],[11,"evaluator_input","","",2,[[["self"],["u16"]],["ref"]]],[11,"constant","","",2,[[["self"],["u16"],["u16"]],["ref"]]],[11,"add","","",2,[[["self"],["ref"],["ref"]],["ref"]]],[11,"sub","","",2,[[["self"],["ref"],["ref"]],["ref"]]],[11,"cmul","","",2,[[["self"],["ref"],["u16"]],["ref"]]],[11,"proj","","",2,N],[11,"mul","","",2,[[["self"],["ref"],["ref"]],["ref"]]],[11,"output","","",2,[[["self"],["ref"]]]],[11,"garbler_input","fancy_garbling::garble","",5,[[["self"],["u16"]],["wire"]]],[11,"evaluator_input","","",5,[[["self"],["u16"]],["wire"]]],[11,"constant","","",5,[[["self"],["u16"],["u16"]],["wire"]]],[11,"add","","",5,[[["self"],["wire"],["wire"]],["wire"]]],[11,"sub","","",5,[[["self"],["wire"],["wire"]],["wire"]]],[11,"cmul","","",5,[[["self"],["wire"],["u16"]],["wire"]]],[11,"mul","","",5,[[["self"],["wire"],["wire"]],["wire"]]],[11,"proj","","",5,N],[11,"output","","",5,[[["self"],["wire"]]]],[11,"garbler_input","","",6,[[["self"],["u16"]],["wire"]]],[11,"evaluator_input","","",6,[[["self"],["u16"]],["wire"]]],[11,"constant","","",6,[[["self"],["u16"],["u16"]],["wire"]]],[11,"add","","",6,[[["self"],["wire"],["wire"]],["wire"]]],[11,"sub","","",6,[[["self"],["wire"],["wire"]],["wire"]]],[11,"cmul","","",6,[[["self"],["wire"],["u16"]],["wire"]]],[11,"mul","","",6,[[["self"],["wire"],["wire"]],["wire"]]],[11,"proj","","",6,N],[11,"output","","",6,[[["self"],["wire"]]]],[11,"garbler_input","fancy_garbling::dummy","",17,[[["self"],["u16"]],["dummyval"]]],[11,"evaluator_input","","",17,[[["self"],["u16"]],["dummyval"]]],[11,"constant","","",17,[[["self"],["u16"],["u16"]],["dummyval"]]],[11,"add","","",17,[[["self"],["dummyval"],["dummyval"]],["dummyval"]]],[11,"sub","","",17,[[["self"],["dummyval"],["dummyval"]],["dummyval"]]],[11,"cmul","","",17,[[["self"],["dummyval"],["u16"]],["dummyval"]]],[11,"mul","","",17,[[["self"],["dummyval"],["dummyval"]],["dummyval"]]],[11,"proj","","",17,N],[11,"output","","",17,[[["self"],["dummyval"]]]],[11,"garbler_input","fancy_garbling::informer","",18,[[["self"],["u16"]],["informerval"]]],[11,"evaluator_input","","",18,[[["self"],["u16"]],["informerval"]]],[11,"constant","","",18,[[["self"],["u16"],["u16"]],["informerval"]]],[11,"add","","",18,[[["self"],["informerval"],["informerval"]],["informerval"]]],[11,"sub","","",18,[[["self"],["informerval"],["informerval"]],["informerval"]]],[11,"cmul","","",18,[[["self"],["informerval"],["u16"]],["informerval"]]],[11,"mul","","",18,[[["self"],["informerval"],["informerval"]],["informerval"]]],[11,"proj","","",18,N],[11,"output","","",18,[[["self"],["informerval"]]]],[11,"partial_cmp","fancy_garbling::wire","",10,[[["self"],["wire"]],["option",["ordering"]]]],[11,"lt","","",10,[[["self"],["wire"]],["bool"]]],[11,"le","","",10,[[["self"],["wire"]],["bool"]]],[11,"gt","","",10,[[["self"],["wire"]],["bool"]]],[11,"ge","","",10,[[["self"],["wire"]],["bool"]]],[11,"default","fancy_garbling::circuit","",0,[[],["ref"]]],[11,"default","fancy_garbling::wire","",10,[[],["wire"]]],[11,"default","fancy_garbling::fancy","",16,[[],["bundle"]]],[11,"default","fancy_garbling::dummy","",19,[[],["dummyval"]]],[11,"default","fancy_garbling::informer","",20,[[],["informerval"]]],[11,"eq","fancy_garbling::circuit","",0,[[["self"],["ref"]],["bool"]]],[11,"ne","","",0,[[["self"],["ref"]],["bool"]]],[11,"eq","","",1,[[["self"],["circuit"]],["bool"]]],[11,"ne","","",1,[[["self"],["circuit"]],["bool"]]],[11,"eq","","",3,[[["self"],["gate"]],["bool"]]],[11,"ne","","",3,[[["self"],["gate"]],["bool"]]],[11,"eq","fancy_garbling::garble","",7,[[["self"],["garbledcircuit"]],["bool"]]],[11,"ne","","",7,[[["self"],["garbledcircuit"]],["bool"]]],[11,"eq","","",8,[[["self"],["encoder"]],["bool"]]],[11,"ne","","",8,[[["self"],["encoder"]],["bool"]]],[11,"eq","","",9,[[["self"],["decoder"]],["bool"]]],[11,"ne","","",9,[[["self"],["decoder"]],["bool"]]],[11,"eq","fancy_garbling::wire","",10,[[["self"],["wire"]],["bool"]]],[11,"ne","","",10,[[["self"],["wire"]],["bool"]]],[11,"clone","fancy_garbling::circuit","",0,[[["self"]],["ref"]]],[11,"clone","","",1,[[["self"]],["circuit"]]],[11,"clone","","",3,[[["self"]],["gate"]]],[11,"clone","fancy_garbling::wire","",10,[[["self"]],["wire"]]],[11,"clone","fancy_garbling::aes","",12,[[["self"]],["self"]]],[11,"clone","fancy_garbling::fancy","",16,[[["self"]],["bundle"]]],[11,"clone","fancy_garbling::dummy","",19,[[["self"]],["dummyval"]]],[11,"clone","fancy_garbling::informer","",20,[[["self"]],["informerval"]]],[11,"fmt","fancy_garbling::garble","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling::circuit","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",1,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling::garble","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling::wire","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling::dummy","",19,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling::informer","",20,[[["self"],["formatter"]],["result"]]],[11,"serialize","fancy_garbling::circuit","",0,[[["self"],["__s"]],["result"]]],[11,"serialize","","",1,[[["self"],["__s"]],["result"]]],[11,"serialize","","",3,[[["self"],["__s"]],["result"]]],[11,"serialize","fancy_garbling::garble","",4,[[["self"],["__s"]],["result"]]],[11,"serialize","","",7,[[["self"],["__s"]],["result"]]],[11,"serialize","","",8,[[["self"],["__s"]],["result"]]],[11,"serialize","","",9,[[["self"],["__s"]],["result"]]],[11,"serialize","fancy_garbling::wire","",10,[[["self"],["__s"]],["result"]]],[11,"deserialize","fancy_garbling::circuit","",0,[[["__d"]],["result"]]],[11,"deserialize","","",1,[[["__d"]],["result"]]],[11,"deserialize","","",3,[[["__d"]],["result"]]],[11,"deserialize","fancy_garbling::garble","",4,[[["__d"]],["result"]]],[11,"deserialize","","",7,[[["__d"]],["result"]]],[11,"deserialize","","",8,[[["__d"]],["result"]]],[11,"deserialize","","",9,[[["__d"]],["result"]]],[11,"deserialize","fancy_garbling::wire","",10,[[["__d"]],["result"]]]],"paths":[[3,"Ref"],[3,"Circuit"],[3,"CircuitBuilder"],[4,"Gate"],[4,"Message"],[3,"Garbler"],[3,"Evaluator"],[3,"GarbledCircuit"],[3,"Encoder"],[3,"Decoder"],[4,"Wire"],[8,"RngExt"],[3,"Aes"],[8,"HasModulus"],[8,"Fancy"],[8,"BundleGadgets"],[3,"Bundle"],[3,"Dummy"],[3,"Informer"],[3,"DummyVal"],[3,"InformerVal"]]};
initSearch(searchIndex);
