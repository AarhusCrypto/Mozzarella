var N = null;var searchIndex = {};
searchIndex["fancy_garbling"]={"doc":"","items":[[3,"Bundle","fancy_garbling","A collection of wires, useful for the garbled gadgets defined by `BundleGadgets`.",N,N],[3,"Decoder","","Decode outputs statically. Created by the `garble` function.",N,N],[3,"Encoder","","Encode inputs statically. Created by the `garble` function.",N,N],[3,"Evaluator","","Streaming evaluator using a callback to receive ciphertexts as needed.",N,N],[3,"GarbledCircuit","","Static evaluator for a circuit, created by the `garble` function.",N,N],[3,"Garbler","","Streams garbled circuit ciphertexts through a callback. Parallelizable.",N,N],[4,"Message","","The outputs that can be emitted by a Garbler and consumed by an Evaluator.",N,N],[13,"UnencodedGarblerInput","","Zero wire and delta for one of the garbler's inputs.",0,N],[12,"zero","fancy_garbling::Message","",0,N],[12,"delta","","",0,N],[13,"UnencodedEvaluatorInput","fancy_garbling","Zero wire and delta for one of the evaluator's inputs.",0,N],[12,"zero","fancy_garbling::Message","",0,N],[12,"delta","","",0,N],[13,"GarblerInput","fancy_garbling","Encoded input for one of the garbler's inputs.",0,N],[13,"EvaluatorInput","","Encoded input for one of the evaluator's inputs.",0,N],[13,"Constant","","Constant wire carrying the value.",0,N],[12,"value","fancy_garbling::Message","",0,N],[12,"wire","","",0,N],[13,"GarbledGate","fancy_garbling","Garbled gate emitted by a projection or multiplication.",0,N],[13,"OutputCiphertext","","Output decoding information.",0,N],[13,"EndSync","","End synchronization mode.",0,N],[4,"Wire","","The essential wirelabel type used by garbled circuits.",N,N],[13,"Mod2","","",1,N],[12,"val","fancy_garbling::Wire","",1,N],[13,"ModN","fancy_garbling","",1,N],[12,"q","fancy_garbling::Wire","",1,N],[12,"ds","","",1,N],[5,"garble_iter","fancy_garbling","Create an iterator over the messages produced by fancy garbling.",N,N],[5,"garble","","Garble a circuit without streaming.",N,[[["circuit"]],["result",["fancyerror"]]]],[0,"circuit","","DSL for creating circuits compatible with fancy-garbling in the old-fashioned way, where you create a circuit for a computation then garble it.",N,N],[3,"CircuitRef","fancy_garbling::circuit","The index and modulus of a gate in a circuit.",N,N],[12,"ix","","",2,N],[3,"Circuit","","Static representation of the type of computation supported by fancy garbling.",N,N],[12,"gates","","",3,N],[12,"gate_moduli","","",3,N],[12,"garbler_input_refs","","",3,N],[12,"evaluator_input_refs","","",3,N],[12,"const_refs","","",3,N],[12,"output_refs","","",3,N],[3,"CircuitBuilder","","CircuitBuilder is used to build circuits.",N,N],[4,"Gate","","The most basic types of computation supported by fancy garbling.",N,N],[13,"GarblerInput","","",4,N],[12,"id","fancy_garbling::circuit::Gate","",4,N],[13,"EvaluatorInput","fancy_garbling::circuit","",4,N],[12,"id","fancy_garbling::circuit::Gate","",4,N],[13,"Constant","fancy_garbling::circuit","",4,N],[12,"val","fancy_garbling::circuit::Gate","",4,N],[13,"Add","fancy_garbling::circuit","",4,N],[12,"xref","fancy_garbling::circuit::Gate","",4,N],[12,"yref","","",4,N],[12,"out","","",4,N],[13,"Sub","fancy_garbling::circuit","",4,N],[12,"xref","fancy_garbling::circuit::Gate","",4,N],[12,"yref","","",4,N],[12,"out","","",4,N],[13,"Cmul","fancy_garbling::circuit","",4,N],[12,"xref","fancy_garbling::circuit::Gate","",4,N],[12,"c","","",4,N],[12,"out","","",4,N],[13,"Mul","fancy_garbling::circuit","",4,N],[12,"xref","fancy_garbling::circuit::Gate","",4,N],[12,"yref","","",4,N],[12,"id","","",4,N],[12,"out","","",4,N],[13,"Proj","fancy_garbling::circuit","",4,N],[12,"xref","fancy_garbling::circuit::Gate","",4,N],[12,"tt","","",4,N],[12,"id","","",4,N],[12,"out","","",4,N],[11,"new","fancy_garbling::circuit","",3,[[["option",["usize"]]],["circuit"]]],[11,"eval","","",3,[[["self"],["f"]],["result",["vec","fancyerror"]]]],[11,"process_outputs","","",3,N],[11,"eval_plain","","Evaluate the circuit in plaintext.",3,N],[11,"info","","Print circuit info.",3,[[["self"]],["result",["fancyerror"]]]],[11,"num_garbler_inputs","","",3,[[["self"]],["usize"]]],[11,"num_evaluator_inputs","","",3,[[["self"]],["usize"]]],[11,"noutputs","","",3,[[["self"]],["usize"]]],[11,"modulus","","",3,[[["self"],["usize"]],["u16"]]],[11,"garbler_input_mod","","",3,[[["self"],["usize"]],["u16"]]],[11,"evaluator_input_mod","","",3,[[["self"],["usize"]],["u16"]]],[11,"new","","",5,[[],["self"]]],[11,"finish","","",5,[[["self"]],["circuit"]]],[0,"dummy","fancy_garbling","Dummy implementation of Fancy.",N,N],[3,"Dummy","fancy_garbling::dummy","Simple struct that performs the fancy computation over u16.",N,N],[3,"DummyVal","","Wrapper around u16.",N,N],[11,"new","","Create a new Dummy.",6,N],[11,"get_output","","Get the output from the fancy computation, consuming the Dummy.",6,[[["self"]],["vec",["u16"]]]],[0,"error","fancy_garbling","Errors that may be output by this library.",N,N],[3,"CircuitBuilderError","fancy_garbling::error","Errors emitted when building a circuit.",N,N],[3,"InformerError","","Errors emitted when running the informer.",N,N],[4,"FancyError","","Errors that may occur when using the `Fancy` trait. `ClientError` wraps errors from underlying fancy object.",N,N],[13,"UnequalModuli","","",7,N],[13,"NotImplemented","","",7,N],[13,"InvalidArg","","",7,N],[12,"desc","fancy_garbling::error::FancyError","",7,N],[13,"InvalidArgNum","fancy_garbling::error","",7,N],[12,"got","fancy_garbling::error::FancyError","",7,N],[12,"needed","","",7,N],[13,"InvalidArgMod","fancy_garbling::error","",7,N],[12,"got","fancy_garbling::error::FancyError","",7,N],[12,"needed","","",7,N],[13,"ArgNotBinary","fancy_garbling::error","",7,N],[13,"NoTruthTable","","",7,N],[13,"InvalidTruthTable","","",7,N],[13,"UninitializedValue","","",7,N],[13,"ClientError","","",7,N],[4,"SyncError","","Common errors emitted by fancy objects in sync mode.",N,N],[13,"IndexRequired","","",8,N],[13,"IndexOutOfBounds","","",8,N],[13,"IndexUsedOutOfSync","","",8,N],[13,"SyncStartedInSync","","",8,N],[4,"DummyError","","Errors from the dummy fancy object.",N,N],[13,"NotEnoughGarblerInputs","","",9,N],[13,"NotEnoughEvaluatorInputs","","",9,N],[13,"SyncError","","",9,N],[4,"EvaluatorError","","Errors from the evaluator.",N,N],[13,"InvalidMessage","","",10,N],[12,"expected","fancy_garbling::error::EvaluatorError","",10,N],[12,"got","","",10,N],[13,"IndexReceivedInSyncMode","fancy_garbling::error","",10,N],[13,"SyncError","","",10,N],[4,"GarblerError","","Errors from the garbler.",N,N],[13,"AsymmetricHalfGateModuliMax8","","",11,N],[13,"TruthTableRequired","","",11,N],[13,"SyncError","","",11,N],[4,"CircuitParserError","","Errors emitted by the circuit parser.",N,N],[13,"IoError","","",12,N],[13,"RegexError","","",12,N],[13,"ParseIntError","","",12,N],[13,"ParseLineError","","",12,N],[13,"ParseGateError","","",12,N],[11,"map_client_err","","Map the underlying client error type.",7,N],[11,"new","fancy_garbling","Create a new bundle from some wires.",13,[[["vec"]],["bundle"]]],[11,"moduli","","Return the moduli of all the wires in the bundle.",13,[[["self"]],["vec",["u16"]]]],[11,"wires","","Extract the wires from this bundle.",13,N],[11,"size","","Get the number of wires in this bundle.",13,[[["self"]],["usize"]]],[11,"is_binary","","Whether this bundle only contains residues in mod 2.",13,[[["self"]],["bool"]]],[11,"with_moduli","","Returns a new bundle only containing wires with matching moduli.",13,N],[11,"pad","","Pad the Bundle with val, n times.",13,[[["self"],["w"]]]],[11,"extract","","Extract a wire from the Bundle, removing it and returning it.",13,[[["self"],["usize"]],["w"]]],[11,"new","","Create a new Evaluator.",14,[[["f"]],["evaluator"]]],[11,"decode_output","","Decode the output received during the Fancy computation.",14,[[["self"]],["vec",["u16"]]]],[11,"new","","Create a new object from a vector of garbled gates and constant wires.",15,[[["vec",["garbledgate"]],["hashmap",["wire"]]],["self"]]],[11,"size","","The number of 128 bit ciphertexts and constant wires in the garbled circuit.",15,[[["self"]],["usize"]]],[11,"eval","","Evaluate the garbled circuit.",15,N],[11,"new","","",16,[[["vec",["wire"]],["vec",["wire"]],["hashmap",["u16","wire"]]],["self"]]],[11,"num_garbler_inputs","","",16,[[["self"]],["usize"]]],[11,"num_evaluator_inputs","","",16,[[["self"]],["usize"]]],[11,"encode_garbler_input","","",16,[[["self"],["u16"],["usize"]],["wire"]]],[11,"encode_evaluator_input","","",16,[[["self"],["u16"],["usize"]],["wire"]]],[11,"encode_garbler_inputs","","",16,N],[11,"encode_evaluator_inputs","","",16,N],[11,"new","","",17,[[["vec",["vec"]]],["self"]]],[11,"decode","","",17,N],[11,"new","","Create a new garbler.",18,[[["f"]],["garbler"]]],[11,"delta","","Create a delta if it has not been created yet for this modulus, otherwise just return the existing one.",18,[[["self"],["u16"]],["wire"]]],[0,"informer","","Informer runs a fancy computation and learns information from it, like how many of what kind of inputs there are.",N,N],[3,"Informer","fancy_garbling::informer","Implements Fancy. Use to learn information about a fancy computation in a lightweight way.",N,N],[3,"InformerVal","","",N,N],[11,"new","","",19,[[],["informer"]]],[11,"print_info","","Print information about the fancy computation.",19,[[["self"]]]],[11,"num_garbler_inputs","","Number of garbler inputs in the fancy computation.",19,[[["self"]],["usize"]]],[11,"garbler_input_moduli","","Moduli of garbler inputs in the fancy computation.",19,[[["self"]],["vec",["u16"]]]],[11,"num_evaluator_inputs","","Number of evaluator inputs in the fancy computation.",19,[[["self"]],["usize"]]],[11,"evaluator_input_moduli","","Moduli of evaluator inputs in the fancy computation.",19,[[["self"]],["vec",["u16"]]]],[11,"num_consts","","Number of constants in the fancy computation.",19,[[["self"]],["usize"]]],[11,"num_outputs","","Number of outputs in the fancy computation.",19,[[["self"]],["usize"]]],[11,"num_output_ciphertexts","","Number of output ciphertexts.",19,[[["self"]],["usize"]]],[11,"num_adds","","Number of additions in the fancy computation.",19,[[["self"]],["usize"]]],[11,"num_subs","","Number of subtractions in the fancy computation.",19,[[["self"]],["usize"]]],[11,"num_cmuls","","Number of scalar multiplications in the fancy computation.",19,[[["self"]],["usize"]]],[11,"num_muls","","Number of multiplications in the fancy computation.",19,[[["self"]],["usize"]]],[11,"num_projs","","Number of projections in the fancy computation.",19,[[["self"]],["usize"]]],[11,"num_ciphertexts","","Number of ciphertexts in the fancy computation.",19,[[["self"]],["usize"]]],[11,"parse","fancy_garbling::circuit","Generates a new `Circuit` from file `filename`.",3,[[["str"]],["result",["error"]]]],[0,"util","fancy_garbling","Tools useful for interacting with `fancy-garbling`.",N,N],[5,"tweak","fancy_garbling::util","Tweak function for a single item.",N,[[["usize"]],["u128"]]],[5,"tweak2","","Tweak function for two items.",N,[[["u64"],["u64"]],["u128"]]],[5,"output_tweak","","Compute the output tweak for a garbled gate where i is the gate id and k is the value.",N,[[["usize"],["u16"]],["u128"]]],[5,"base_q_add","","Add two base q numbers together.",N,N],[5,"base_q_add_eq","","Add a base q number into the first one.",N,N],[5,"as_base_q","","Convert a `u128` into base `q`.",N,[[["u128"],["u16"],["usize"]],["vec",["u16"]]]],[5,"digits_per_u128","","Determine how many `mod q` digits fit into a `u128`.",N,[[["u16"]],["usize"]]],[5,"as_base_q_u128","","Convert a `u128` into base `q`.",N,[[["u128"],["u16"]],["vec",["u16"]]]],[5,"as_mixed_radix","","Convert a `u128` into mixed radix form with the provided radii.",N,N],[5,"from_base_q","","Convert little-endian base q digits into u128.",N,N],[5,"from_mixed_radix","","Convert little-endian mixed radix digits into u128.",N,N],[5,"u128_to_bits","","Get the bits of a u128 encoded in 128 u16s, which is convenient for the rest of the library, which uses u16 as the base digit type in Wire.",N,[[["u128"],["usize"]],["vec",["u16"]]]],[5,"u128_from_bits","","Convert into a u128 from the \"bits\" as u16. Assumes each \"bit\" is 0 or 1.",N,N],[5,"u128_to_bytes","","Convert a u128 into bytes.",N,N],[5,"bytes_to_u128","","Convert bytes to u128.",N,N],[5,"factor","","Factor using the primes in the global `PRIMES` array. Fancy garbling only supports composites with small prime factors.",N,[[["u128"]],["vec",["u16"]]]],[5,"crt","","Compute the CRT representation of x with respect to the primes ps.",N,N],[5,"crt_factor","","Compute the CRT representation of x with respect to the factorization of q.",N,[[["u128"],["u128"]],["vec",["u16"]]]],[5,"crt_inv","","Compute the value x given a list of CRT primes and residues.",N,N],[5,"crt_inv_factor","","Compute the value x given a composite CRT modulus.",N,N],[5,"inv","","Generic algorithm to invert inp_a mod inp_b. As ref so as to support BigInts without copying.",N,[[["i128"],["i128"]],["i128"]]],[5,"modulus_with_nprimes","","Generate a CRT modulus with n primes.",N,[[["usize"]],["u128"]]],[5,"modulus_with_width","","Generate a CRT modulus that support at least n-bit integers, using the built-in PRIMES.",N,[[["u32"]],["u128"]]],[5,"primes_with_width","","Generate the factors of a CRT modulus that support at least n-bit integers, using the built-in PRIMES.",N,[[["u32"]],["vec",["u16"]]]],[5,"base_modulus_with_width","","Generate a CRT modulus that support at least n-bit integers, using provided primes.",N,N],[5,"base_primes_with_width","","Generate the factors of a CRT modulus that support at least n-bit integers, using provided primes.",N,N],[5,"modulus_with_width_skip2","","Generate a CRT modulus that support at least n-bit integers, using the built-in PRIMES_SKIP_2 (does not include 2 as a factor).",N,[[["u32"]],["u128"]]],[5,"product","","Compute the product of some u16s as a u128.",N,N],[5,"powm","","Raise a u16 to a power mod some value.",N,[[["u16"],["u16"],["u16"]],["u16"]]],[5,"is_power_of_2","","Returns true if x is a power of 2",N,[[["u16"]],["bool"]]],[17,"NPRIMES","","Number of primes supported by our library.",N,N],[17,"PRIMES","","Primes used in fancy garbling.",N,N],[17,"PRIMES_SKIP_2","","Primes skipping the modulus 2, which allows certain gadgets.",N,N],[8,"RngExt","","Extra Rng functionality, useful for `fancy-garbling`.",N,N],[11,"gen_bool","","",20,[[["self"]],["bool"]]],[11,"gen_u16","","",20,[[["self"]],["u16"]]],[11,"gen_u32","","",20,[[["self"]],["u32"]]],[11,"gen_u64","","",20,[[["self"]],["u64"]]],[11,"gen_usize","","",20,[[["self"]],["usize"]]],[11,"gen_u128","","",20,[[["self"]],["u128"]]],[11,"gen_usable_u128","","",20,[[["self"],["u16"]],["u128"]]],[11,"gen_prime","","",20,[[["self"]],["u16"]]],[11,"gen_modulus","","",20,[[["self"]],["u16"]]],[11,"gen_usable_composite_modulus","","",20,[[["self"]],["u128"]]],[11,"gen_usable_factors","","",20,[[["self"]],["vec",["u16"]]]],[11,"digits","fancy_garbling","Get the digits of the wire.",1,[[["self"]],["vec",["u16"]]]],[11,"from_u128","","Get the wire represented by the u128.",1,[[["u128"],["u16"]],["self"]]],[11,"as_u128","","Pack the wire to a u128.",1,[[["self"]],["u128"]]],[11,"zero","","The zero wire for the modulus q.",1,[[["u16"]],["self"]]],[11,"rand_delta","","Get a random wire label for mod q, with the first digit set to 1.",1,[[["r"],["u16"]],["self"]]],[11,"color","","Get the color digit of the wire.",1,[[["self"]],["u16"]]],[11,"plus","","Add two wires digit-wise mod q, returning a new wire.",1,[[["self"],["self"]],["self"]]],[11,"plus_eq","","Add another wire into this one, digit-wise mod q.",1,[[["self"],["wire"]],["wire"]]],[11,"plus_mov","","Add another wire into this one, consuming it for chained computations.",1,[[["self"],["wire"]],["wire"]]],[11,"cmul","","Multiply each digit by a constant c mod q, returning a new wire.",1,[[["self"],["u16"]],["self"]]],[11,"cmul_eq","","Multiply each digit by a constant c mod q.",1,[[["self"],["u16"]],["wire"]]],[11,"cmul_mov","","Multiply each digit by a constant c mod q, consuming it for chained computations.",1,[[["self"],["u16"]],["wire"]]],[11,"negate","","Negate all the digits mod q, returning a new wire.",1,[[["self"]],["self"]]],[11,"negate_eq","","Negate all the digits mod q.",1,[[["self"]],["wire"]]],[11,"negate_mov","","Negate all the digits mod q, consuming it for chained computations.",1,[[["self"]],["wire"]]],[11,"minus","","Subtract two wires, returning the result.",1,[[["self"],["wire"]],["wire"]]],[11,"minus_eq","","Subtract a wire from this one.",1,[[["self"],["wire"]],["wire"]]],[11,"minus_mov","","Subtract a wire from this one, consuming it for chained computations.",1,[[["self"],["wire"]],["wire"]]],[11,"rand","","Get a random wire mod q.",1,[[["r"],["u16"]],["wire"]]],[11,"hash","","Compute the hash of this wire.",1,[[["self"],["u128"]],["u128"]]],[11,"hashback","","Compute the hash of this wire, converting the result back to a wire.",1,[[["self"],["u128"],["u16"]],["wire"]]],[6,"SyncIndex","","The index of a thread for synchronization.",N,N],[6,"GarbledGate","","The ciphertext created by a garbled gate.",N,N],[6,"OutputCiphertext","","Ciphertext created by the garbler for output gates.",N,N],[8,"BundleGadgets","","Extension trait for `Fancy` providing advanced gadgets based on bundles of wires.",N,N],[11,"garbler_input_bundle","","Crate an input bundle for the garbler using moduli `ps` and optional inputs `xs`.",21,N],[11,"evaluator_input_bundle","","Crate an input bundle for the evaluator using moduli `ps`.",21,N],[11,"garbler_input_bundle_crt","","Crate an input bundle for the garbler using composite CRT modulus `q` and optional input `x`.",21,[[["self"],["option",["syncindex"]],["u128"],["option",["u128"]]],["result",["bundle","fancyerror"]]]],[11,"evaluator_input_bundle_crt","","Crate an input bundle for the evaluator using composite CRT modulus `q`.",21,[[["self"],["option",["syncindex"]],["u128"]],["result",["bundle","fancyerror"]]]],[11,"garbler_input_bundle_binary","","Create an input bundle for the garbler using `nbits` base 2 inputs and optional input `x`.",21,[[["self"],["option",["syncindex"]],["usize"],["option",["u128"]]],["result",["bundle","fancyerror"]]]],[11,"evaluator_input_bundle_binary","","Create an input bundle for the evaluator using n base 2 inputs.",21,[[["self"],["option",["syncindex"]],["usize"]],["result",["bundle","fancyerror"]]]],[11,"constant_bundle","","Creates a bundle of constant wires using moduli `ps`.",21,N],[11,"constant_bundle_crt","","Creates a bundle of constant wires for the CRT representation of `x` under composite modulus `q`.",21,[[["self"],["option",["syncindex"]],["u128"],["u128"]],["result",["bundle","fancyerror"]]]],[11,"constant_bundle_binary","","Create a constant bundle using base 2 inputs.",21,[[["self"],["option",["syncindex"]],["u128"],["usize"]],["result",["bundle","fancyerror"]]]],[11,"garbler_input_bundles","","Create `n` garbler input bundles, using moduli `ps` and optional inputs `xs`.",21,N],[11,"evaluator_input_bundles","","Create `n` evaluator input bundles, using moduli `ps`.",21,N],[11,"garbler_input_bundles_crt","","Create `n` garbler input bundles, under composite CRT modulus `q` and optional inputs `xs`.",21,[[["self"],["option",["syncindex"]],["u128"],["usize"],["option",["vec"]]],["result",["vec","fancyerror"]]]],[11,"evaluator_input_bundles_crt","","Create `n` evaluator input bundles, under composite CRT modulus `q`.",21,[[["self"],["option",["syncindex"]],["u128"],["usize"]],["result",["vec","fancyerror"]]]],[11,"output_bundle","","Output the wires that make up a bundle.",21,[[["self"],["option",["syncindex"]],["bundle"]],["result",["fancyerror"]]]],[11,"output_bundles","","Output a slice of bundles.",21,N],[11,"add_bundles","","Add two wire bundles, residue by residue.",21,[[["self"],["bundle"],["bundle"]],["result",["bundle","fancyerror"]]]],[11,"sub_bundles","","Subtract two wire bundles, residue by residue.",21,[[["self"],["bundle"],["bundle"]],["result",["bundle","fancyerror"]]]],[11,"cmul_bundle","","Multiplies each wire in `x` by the corresponding residue of `c`.",21,[[["self"],["bundle"],["u128"]],["result",["bundle","fancyerror"]]]],[11,"mul_bundles","","Multiply `x` with `y`.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"]],["result",["bundle","fancyerror"]]]],[11,"cexp_bundle","","Exponentiate `x` by the constant `c`.",21,[[["self"],["option",["syncindex"]],["bundle"],["u16"]],["result",["bundle","fancyerror"]]]],[11,"rem_bundle","","Compute the remainder with respect to modulus `p`.",21,[[["self"],["option",["syncindex"]],["bundle"],["u16"]],["result",["bundle","fancyerror"]]]],[11,"eq_bundles","","Compute `x == y`. Returns a wire encoding the result mod 2.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"]],["result",["fancyerror"]]]],[11,"mixed_radix_addition","","Mixed radix addition.",21,N],[11,"mixed_radix_addition_msb_only","","Mixed radix addition only returning the MSB.",21,N],[11,"fractional_mixed_radix","","Helper function for advanced gadgets, returns the MSB of the fractional part of `X/M` where `M=product(ms)`.",21,N],[11,"relu","","Compute `max(x,0)`.",21,[[["self"],["option",["syncindex"]],["bundle"],["str"],["option"]],["result",["bundle","fancyerror"]]]],[11,"sign","","Return 0 if `x` is positive and 1 if `x` is negative.",21,[[["self"],["option",["syncindex"]],["bundle"],["str"]],["result",["fancyerror"]]]],[11,"sgn","","Return `if x >= 0 then 1 else -1`, where `-1` is interpreted as `Q-1`.",21,[[["self"],["option",["syncindex"]],["bundle"],["str"],["option"]],["result",["bundle","fancyerror"]]]],[11,"lt","","Returns 1 if `x < y`. Works on both CRT and binary bundles.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"],["str"]],["result",["fancyerror"]]]],[11,"geq","","Returns 1 if `x >= y`. Works on both CRT and binary bundles.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"],["str"]],["result",["fancyerror"]]]],[11,"max","","Compute the maximum bundle in `xs`.",21,N],[11,"binary_addition","","Binary addition. Returns the result and the carry.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"]],["result",["fancyerror"]]]],[11,"binary_addition_no_carry","","Binary addition. Avoids creating extra gates for the final carry.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"]],["result",["bundle","fancyerror"]]]],[11,"binary_multiplication_lower_half","","Binary multiplication.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"]],["result",["bundle","fancyerror"]]]],[11,"twos_complement","","Compute the twos complement of the input bundle (which must be base 2).",21,[[["self"],["option",["syncindex"]],["bundle"]],["result",["bundle","fancyerror"]]]],[11,"binary_subtraction","","Subtract two binary bundles. Returns the result and whether it underflowed.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"]],["result",["fancyerror"]]]],[11,"multiplex","","If b=0 then return x, else return y.",21,N],[11,"multiplex_constant_bits","","If `x=0` return `c1` as a bundle of constant bits, else return `c2`.",21,N],[11,"shift","","Shift residues, replacing them with zeros in the modulus of the least signifigant residue.",21,[[["self"],["option",["syncindex"]],["bundle"],["usize"]],["result",["bundle","fancyerror"]]]],[11,"binary_cmul","","Write the constant in binary and that gives you the shift amounts, Eg.. 7x is 4x+2x+x.",21,[[["self"],["option",["syncindex"]],["bundle"],["u128"],["usize"]],["result",["bundle","fancyerror"]]]],[11,"abs","","Compute the absolute value of a binary bundle.",21,[[["self"],["option",["syncindex"]],["bundle"]],["result",["bundle","fancyerror"]]]],[8,"HasModulus","","An object that has some modulus. Basic object of Fancy compuations.",N,N],[10,"modulus","","The modulus of the wire.",22,[[["self"]],["u16"]]],[8,"Fancy","","DSL for the basic computations supported by fancy-garbling.",N,N],[16,"Item","","The underlying wire datatype created by an object implementing `Fancy`.",23,N],[16,"Error","","Errors which may be thrown by the users of Fancy.",23,N],[10,"garbler_input","","Create an input for the garbler with modulus `q` and optional garbler-private value `x`.",23,[[["self"],["option",["syncindex"]],["u16"],["option",["u16"]]],["result",["fancyerror"]]]],[10,"evaluator_input","","Create an input for the evaluator with modulus `q`.",23,[[["self"],["option",["syncindex"]],["u16"]],["result",["fancyerror"]]]],[10,"constant","","Create a constant `x` with modulus `q`.",23,[[["self"],["option",["syncindex"]],["u16"],["u16"]],["result",["fancyerror"]]]],[10,"add","","Add `x` and `y`.",23,N],[10,"sub","","Subtract `x` and `y`.",23,N],[10,"cmul","","Multiply `x` times the constant `c`.",23,N],[10,"mul","","Multiply `x` and `y`.",23,N],[10,"proj","","Project `x` according to the truth table `tt`. Resulting wire has modulus `q`.",23,N],[10,"output","","Process this wire as output.",23,N],[11,"begin_sync","","Start synchronization of internal messages.",23,[[["self"],["syncindex"]],["result",["fancyerror"]]]],[11,"finish_index","","Declare this index to be done.",23,[[["self"],["syncindex"]],["result",["fancyerror"]]]],[11,"garbler_inputs","","Create `n` garbler inputs with the moduli `qs` and optional inputs `xs`.",23,N],[11,"evaluator_inputs","","Create `n` evaluator inputs with the moduli `qs`.",23,N],[11,"add_many","","Sum up a slice of wires.",23,N],[11,"xor","","Xor is just addition, with the requirement that `x` and `y` are mod 2.",23,N],[11,"negate","","Negate by xoring `x` with `1`.",23,N],[11,"and","","And is just multiplication, with the requirement that `x` and `y` are mod 2.",23,N],[11,"or","","Or uses Demorgan's Rule implemented with multiplication and negation.",23,N],[11,"and_many","","Returns 1 if all wires equal 1.",23,N],[11,"or_many","","Returns 1 if any wire equals 1.",23,N],[11,"mod_change","","Change the modulus of `x` to `to_modulus` using a projection gate.",23,N],[11,"adder","","Binary adder. Returns the result and the carry.",23,N],[11,"mux","","If `b=0` returns `x` else `y`.",23,N],[11,"mux_constant_bits","","If `x=0` return the constant `b1` else return `b2`. Folds constants if possible.",23,N],[11,"outputs","","Output a slice of wires.",23,N],[11,"into","","",13,[[["self"]],["u"]]],[11,"to_owned","","",13,[[["self"]],["t"]]],[11,"clone_into","","",13,N],[11,"from","","",13,[[["t"]],["t"]]],[11,"try_from","","",13,[[["u"]],["result"]]],[11,"borrow","","",13,[[["self"]],["t"]]],[11,"get_type_id","","",13,[[["self"]],["typeid"]]],[11,"try_into","","",13,[[["self"]],["result"]]],[11,"borrow_mut","","",13,[[["self"]],["t"]]],[11,"into","","",17,[[["self"]],["u"]]],[11,"from","","",17,[[["t"]],["t"]]],[11,"try_from","","",17,[[["u"]],["result"]]],[11,"borrow","","",17,[[["self"]],["t"]]],[11,"get_type_id","","",17,[[["self"]],["typeid"]]],[11,"try_into","","",17,[[["self"]],["result"]]],[11,"borrow_mut","","",17,[[["self"]],["t"]]],[11,"into","","",16,[[["self"]],["u"]]],[11,"from","","",16,[[["t"]],["t"]]],[11,"try_from","","",16,[[["u"]],["result"]]],[11,"borrow","","",16,[[["self"]],["t"]]],[11,"get_type_id","","",16,[[["self"]],["typeid"]]],[11,"try_into","","",16,[[["self"]],["result"]]],[11,"borrow_mut","","",16,[[["self"]],["t"]]],[11,"into","","",14,[[["self"]],["u"]]],[11,"from","","",14,[[["t"]],["t"]]],[11,"try_from","","",14,[[["u"]],["result"]]],[11,"borrow","","",14,[[["self"]],["t"]]],[11,"get_type_id","","",14,[[["self"]],["typeid"]]],[11,"try_into","","",14,[[["self"]],["result"]]],[11,"borrow_mut","","",14,[[["self"]],["t"]]],[11,"into","","",15,[[["self"]],["u"]]],[11,"from","","",15,[[["t"]],["t"]]],[11,"try_from","","",15,[[["u"]],["result"]]],[11,"borrow","","",15,[[["self"]],["t"]]],[11,"get_type_id","","",15,[[["self"]],["typeid"]]],[11,"try_into","","",15,[[["self"]],["result"]]],[11,"borrow_mut","","",15,[[["self"]],["t"]]],[11,"into","","",18,[[["self"]],["u"]]],[11,"from","","",18,[[["t"]],["t"]]],[11,"try_from","","",18,[[["u"]],["result"]]],[11,"borrow","","",18,[[["self"]],["t"]]],[11,"get_type_id","","",18,[[["self"]],["typeid"]]],[11,"try_into","","",18,[[["self"]],["result"]]],[11,"borrow_mut","","",18,[[["self"]],["t"]]],[11,"into","","",0,[[["self"]],["u"]]],[11,"to_string","","",0,[[["self"]],["string"]]],[11,"to_owned","","",0,[[["self"]],["t"]]],[11,"clone_into","","",0,N],[11,"from","","",0,[[["t"]],["t"]]],[11,"try_from","","",0,[[["u"]],["result"]]],[11,"borrow","","",0,[[["self"]],["t"]]],[11,"get_type_id","","",0,[[["self"]],["typeid"]]],[11,"try_into","","",0,[[["self"]],["result"]]],[11,"borrow_mut","","",0,[[["self"]],["t"]]],[11,"into","","",1,[[["self"]],["u"]]],[11,"to_owned","","",1,[[["self"]],["t"]]],[11,"clone_into","","",1,N],[11,"from","","",1,[[["t"]],["t"]]],[11,"try_from","","",1,[[["u"]],["result"]]],[11,"borrow","","",1,[[["self"]],["t"]]],[11,"get_type_id","","",1,[[["self"]],["typeid"]]],[11,"try_into","","",1,[[["self"]],["result"]]],[11,"borrow_mut","","",1,[[["self"]],["t"]]],[11,"into","fancy_garbling::circuit","",2,[[["self"]],["u"]]],[11,"to_string","","",2,[[["self"]],["string"]]],[11,"to_owned","","",2,[[["self"]],["t"]]],[11,"clone_into","","",2,N],[11,"from","","",2,[[["t"]],["t"]]],[11,"try_from","","",2,[[["u"]],["result"]]],[11,"borrow","","",2,[[["self"]],["t"]]],[11,"get_type_id","","",2,[[["self"]],["typeid"]]],[11,"try_into","","",2,[[["self"]],["result"]]],[11,"borrow_mut","","",2,[[["self"]],["t"]]],[11,"into","","",3,[[["self"]],["u"]]],[11,"to_owned","","",3,[[["self"]],["t"]]],[11,"clone_into","","",3,N],[11,"from","","",3,[[["t"]],["t"]]],[11,"try_from","","",3,[[["u"]],["result"]]],[11,"borrow","","",3,[[["self"]],["t"]]],[11,"get_type_id","","",3,[[["self"]],["typeid"]]],[11,"try_into","","",3,[[["self"]],["result"]]],[11,"borrow_mut","","",3,[[["self"]],["t"]]],[11,"into","","",5,[[["self"]],["u"]]],[11,"from","","",5,[[["t"]],["t"]]],[11,"try_from","","",5,[[["u"]],["result"]]],[11,"borrow","","",5,[[["self"]],["t"]]],[11,"get_type_id","","",5,[[["self"]],["typeid"]]],[11,"try_into","","",5,[[["self"]],["result"]]],[11,"borrow_mut","","",5,[[["self"]],["t"]]],[11,"into","","",4,[[["self"]],["u"]]],[11,"to_string","","",4,[[["self"]],["string"]]],[11,"to_owned","","",4,[[["self"]],["t"]]],[11,"clone_into","","",4,N],[11,"from","","",4,[[["t"]],["t"]]],[11,"try_from","","",4,[[["u"]],["result"]]],[11,"borrow","","",4,[[["self"]],["t"]]],[11,"get_type_id","","",4,[[["self"]],["typeid"]]],[11,"try_into","","",4,[[["self"]],["result"]]],[11,"borrow_mut","","",4,[[["self"]],["t"]]],[11,"into","fancy_garbling::dummy","",6,[[["self"]],["u"]]],[11,"from","","",6,[[["t"]],["t"]]],[11,"try_from","","",6,[[["u"]],["result"]]],[11,"borrow","","",6,[[["self"]],["t"]]],[11,"get_type_id","","",6,[[["self"]],["typeid"]]],[11,"try_into","","",6,[[["self"]],["result"]]],[11,"borrow_mut","","",6,[[["self"]],["t"]]],[11,"into","","",24,[[["self"]],["u"]]],[11,"to_owned","","",24,[[["self"]],["t"]]],[11,"clone_into","","",24,N],[11,"from","","",24,[[["t"]],["t"]]],[11,"try_from","","",24,[[["u"]],["result"]]],[11,"borrow","","",24,[[["self"]],["t"]]],[11,"get_type_id","","",24,[[["self"]],["typeid"]]],[11,"try_into","","",24,[[["self"]],["result"]]],[11,"borrow_mut","","",24,[[["self"]],["t"]]],[11,"into","fancy_garbling::error","",25,[[["self"]],["u"]]],[11,"to_string","","",25,[[["self"]],["string"]]],[11,"from","","",25,[[["t"]],["t"]]],[11,"try_from","","",25,[[["u"]],["result"]]],[11,"borrow","","",25,[[["self"]],["t"]]],[11,"get_type_id","","",25,[[["self"]],["typeid"]]],[11,"try_into","","",25,[[["self"]],["result"]]],[11,"borrow_mut","","",25,[[["self"]],["t"]]],[11,"into","","",26,[[["self"]],["u"]]],[11,"to_string","","",26,[[["self"]],["string"]]],[11,"from","","",26,[[["t"]],["t"]]],[11,"try_from","","",26,[[["u"]],["result"]]],[11,"borrow","","",26,[[["self"]],["t"]]],[11,"get_type_id","","",26,[[["self"]],["typeid"]]],[11,"try_into","","",26,[[["self"]],["result"]]],[11,"borrow_mut","","",26,[[["self"]],["t"]]],[11,"into","","",7,[[["self"]],["u"]]],[11,"to_string","","",7,[[["self"]],["string"]]],[11,"from","","",7,[[["t"]],["t"]]],[11,"try_from","","",7,[[["u"]],["result"]]],[11,"borrow","","",7,[[["self"]],["t"]]],[11,"get_type_id","","",7,[[["self"]],["typeid"]]],[11,"try_into","","",7,[[["self"]],["result"]]],[11,"borrow_mut","","",7,[[["self"]],["t"]]],[11,"into","","",8,[[["self"]],["u"]]],[11,"to_string","","",8,[[["self"]],["string"]]],[11,"from","","",8,[[["t"]],["t"]]],[11,"try_from","","",8,[[["u"]],["result"]]],[11,"borrow","","",8,[[["self"]],["t"]]],[11,"get_type_id","","",8,[[["self"]],["typeid"]]],[11,"try_into","","",8,[[["self"]],["result"]]],[11,"borrow_mut","","",8,[[["self"]],["t"]]],[11,"into","","",9,[[["self"]],["u"]]],[11,"to_string","","",9,[[["self"]],["string"]]],[11,"from","","",9,[[["t"]],["t"]]],[11,"try_from","","",9,[[["u"]],["result"]]],[11,"borrow","","",9,[[["self"]],["t"]]],[11,"get_type_id","","",9,[[["self"]],["typeid"]]],[11,"try_into","","",9,[[["self"]],["result"]]],[11,"borrow_mut","","",9,[[["self"]],["t"]]],[11,"into","","",10,[[["self"]],["u"]]],[11,"to_string","","",10,[[["self"]],["string"]]],[11,"from","","",10,[[["t"]],["t"]]],[11,"try_from","","",10,[[["u"]],["result"]]],[11,"borrow","","",10,[[["self"]],["t"]]],[11,"get_type_id","","",10,[[["self"]],["typeid"]]],[11,"try_into","","",10,[[["self"]],["result"]]],[11,"borrow_mut","","",10,[[["self"]],["t"]]],[11,"into","","",11,[[["self"]],["u"]]],[11,"to_string","","",11,[[["self"]],["string"]]],[11,"from","","",11,[[["t"]],["t"]]],[11,"try_from","","",11,[[["u"]],["result"]]],[11,"borrow","","",11,[[["self"]],["t"]]],[11,"get_type_id","","",11,[[["self"]],["typeid"]]],[11,"try_into","","",11,[[["self"]],["result"]]],[11,"borrow_mut","","",11,[[["self"]],["t"]]],[11,"into","","",12,[[["self"]],["u"]]],[11,"to_string","","",12,[[["self"]],["string"]]],[11,"from","","",12,[[["t"]],["t"]]],[11,"try_from","","",12,[[["u"]],["result"]]],[11,"borrow","","",12,[[["self"]],["t"]]],[11,"get_type_id","","",12,[[["self"]],["typeid"]]],[11,"try_into","","",12,[[["self"]],["result"]]],[11,"borrow_mut","","",12,[[["self"]],["t"]]],[11,"into","fancy_garbling::informer","",19,[[["self"]],["u"]]],[11,"from","","",19,[[["t"]],["t"]]],[11,"try_from","","",19,[[["u"]],["result"]]],[11,"borrow","","",19,[[["self"]],["t"]]],[11,"get_type_id","","",19,[[["self"]],["typeid"]]],[11,"try_into","","",19,[[["self"]],["result"]]],[11,"borrow_mut","","",19,[[["self"]],["t"]]],[11,"into","","",27,[[["self"]],["u"]]],[11,"to_owned","","",27,[[["self"]],["t"]]],[11,"clone_into","","",27,N],[11,"from","","",27,[[["t"]],["t"]]],[11,"try_from","","",27,[[["u"]],["result"]]],[11,"borrow","","",27,[[["self"]],["t"]]],[11,"get_type_id","","",27,[[["self"]],["typeid"]]],[11,"try_into","","",27,[[["self"]],["result"]]],[11,"borrow_mut","","",27,[[["self"]],["t"]]],[11,"modulus","fancy_garbling::circuit","",2,[[["self"]],["u16"]]],[11,"modulus","fancy_garbling::dummy","",24,[[["self"]],["u16"]]],[11,"modulus","fancy_garbling::informer","",27,[[["self"]],["u16"]]],[11,"modulus","fancy_garbling","",1,[[["self"]],["u16"]]],[11,"garbler_input","fancy_garbling::circuit","",5,[[["self"],["option",["syncindex"]],["u16"],["option",["u16"]]],["result",["circuitref","fancyerror"]]]],[11,"evaluator_input","","",5,[[["self"],["option",["syncindex"]],["u16"]],["result",["circuitref","fancyerror"]]]],[11,"constant","","",5,[[["self"],["option",["syncindex"]],["u16"],["u16"]],["result",["circuitref","fancyerror"]]]],[11,"add","","",5,[[["self"],["circuitref"],["circuitref"]],["result",["circuitref","fancyerror"]]]],[11,"sub","","",5,[[["self"],["circuitref"],["circuitref"]],["result",["circuitref","fancyerror"]]]],[11,"cmul","","",5,[[["self"],["circuitref"],["u16"]],["result",["circuitref","fancyerror"]]]],[11,"proj","","",5,[[["self"],["option",["syncindex"]],["circuitref"],["u16"],["option",["vec"]]],["result",["circuitref","fancyerror"]]]],[11,"mul","","",5,[[["self"],["option",["syncindex"]],["circuitref"],["circuitref"]],["result",["circuitref","fancyerror"]]]],[11,"output","","",5,[[["self"],["option",["syncindex"]],["circuitref"]],["result",["fancyerror"]]]],[11,"garbler_input","fancy_garbling::dummy","",6,[[["self"],["option",["syncindex"]],["u16"],["option",["u16"]]],["result",["dummyval","fancyerror"]]]],[11,"evaluator_input","","",6,[[["self"],["option",["syncindex"]],["u16"]],["result",["dummyval","fancyerror"]]]],[11,"constant","","",6,[[["self"],["option",["syncindex"]],["u16"],["u16"]],["result",["dummyval","fancyerror"]]]],[11,"add","","",6,[[["self"],["dummyval"],["dummyval"]],["result",["dummyval","fancyerror"]]]],[11,"sub","","",6,[[["self"],["dummyval"],["dummyval"]],["result",["dummyval","fancyerror"]]]],[11,"cmul","","",6,[[["self"],["dummyval"],["u16"]],["result",["dummyval","fancyerror"]]]],[11,"mul","","",6,[[["self"],["option",["syncindex"]],["dummyval"],["dummyval"]],["result",["dummyval","fancyerror"]]]],[11,"proj","","",6,[[["self"],["option",["syncindex"]],["dummyval"],["u16"],["option",["vec"]]],["result",["dummyval","fancyerror"]]]],[11,"output","","",6,[[["self"],["option",["syncindex"]],["dummyval"]],["result",["fancyerror"]]]],[11,"begin_sync","","",6,[[["self"],["syncindex"]],["result",["fancyerror"]]]],[11,"finish_index","","",6,[[["self"],["syncindex"]],["result",["fancyerror"]]]],[11,"garbler_input","fancy_garbling","",14,[[["self"],["option",["syncindex"]],["u16"],["option",["u16"]]],["result",["wire","fancyerror"]]]],[11,"evaluator_input","","",14,[[["self"],["option",["syncindex"]],["u16"]],["result",["wire","fancyerror"]]]],[11,"constant","","",14,[[["self"],["option",["syncindex"]],["u16"],["u16"]],["result",["wire","fancyerror"]]]],[11,"add","","",14,[[["self"],["wire"],["wire"]],["result",["wire","fancyerror"]]]],[11,"sub","","",14,[[["self"],["wire"],["wire"]],["result",["wire","fancyerror"]]]],[11,"cmul","","",14,[[["self"],["wire"],["u16"]],["result",["wire","fancyerror"]]]],[11,"mul","","",14,[[["self"],["option",["syncindex"]],["wire"],["wire"]],["result",["wire","fancyerror"]]]],[11,"proj","","",14,[[["self"],["option",["syncindex"]],["wire"],["u16"],["option",["vec"]]],["result",["wire","fancyerror"]]]],[11,"output","","",14,[[["self"],["option",["syncindex"]],["wire"]],["result",["fancyerror"]]]],[11,"begin_sync","","",14,[[["self"],["syncindex"]],["result",["fancyerror"]]]],[11,"finish_index","","",14,[[["self"],["syncindex"]],["result",["fancyerror"]]]],[11,"garbler_input","","",18,[[["self"],["option",["syncindex"]],["u16"],["option",["u16"]]],["result",["wire","fancyerror"]]]],[11,"evaluator_input","","",18,[[["self"],["option",["syncindex"]],["u16"]],["result",["wire","fancyerror"]]]],[11,"constant","","",18,[[["self"],["option",["syncindex"]],["u16"],["u16"]],["result",["wire","fancyerror"]]]],[11,"add","","",18,[[["self"],["wire"],["wire"]],["result",["wire","fancyerror"]]]],[11,"sub","","",18,[[["self"],["wire"],["wire"]],["result",["wire","fancyerror"]]]],[11,"cmul","","",18,[[["self"],["wire"],["u16"]],["result",["wire","fancyerror"]]]],[11,"mul","","",18,[[["self"],["option",["syncindex"]],["wire"],["wire"]],["result",["wire","fancyerror"]]]],[11,"proj","","",18,[[["self"],["option",["syncindex"]],["wire"],["u16"],["option",["vec"]]],["result",["wire","fancyerror"]]]],[11,"output","","",18,[[["self"],["option",["syncindex"]],["wire"]],["result",["fancyerror"]]]],[11,"begin_sync","","",18,[[["self"],["syncindex"]],["result",["fancyerror"]]]],[11,"finish_index","","",18,[[["self"],["syncindex"]],["result",["fancyerror"]]]],[11,"garbler_input","fancy_garbling::informer","",19,[[["self"],["option",["syncindex"]],["u16"],["option",["u16"]]],["result",["informerval","fancyerror"]]]],[11,"evaluator_input","","",19,[[["self"],["option",["syncindex"]],["u16"]],["result",["informerval","fancyerror"]]]],[11,"constant","","",19,[[["self"],["option",["syncindex"]],["u16"],["u16"]],["result",["informerval","fancyerror"]]]],[11,"add","","",19,[[["self"],["informerval"],["informerval"]],["result",["informerval","fancyerror"]]]],[11,"sub","","",19,[[["self"],["informerval"],["informerval"]],["result",["informerval","fancyerror"]]]],[11,"cmul","","",19,[[["self"],["informerval"],["u16"]],["result",["informerval","fancyerror"]]]],[11,"mul","","",19,[[["self"],["option",["syncindex"]],["informerval"],["informerval"]],["result",["informerval","fancyerror"]]]],[11,"proj","","",19,[[["self"],["option",["syncindex"]],["informerval"],["u16"],["option",["vec"]]],["result",["informerval","fancyerror"]]]],[11,"output","","",19,[[["self"],["option",["syncindex"]],["informerval"]],["result",["fancyerror"]]]],[11,"default","fancy_garbling","",1,[[],["self"]]],[11,"eq","fancy_garbling::circuit","",2,[[["self"],["circuitref"]],["bool"]]],[11,"ne","","",2,[[["self"],["circuitref"]],["bool"]]],[11,"eq","","",3,[[["self"],["circuit"]],["bool"]]],[11,"ne","","",3,[[["self"],["circuit"]],["bool"]]],[11,"eq","","",4,[[["self"],["gate"]],["bool"]]],[11,"ne","","",4,[[["self"],["gate"]],["bool"]]],[11,"eq","fancy_garbling","",15,[[["self"],["garbledcircuit"]],["bool"]]],[11,"ne","","",15,[[["self"],["garbledcircuit"]],["bool"]]],[11,"eq","","",16,[[["self"],["encoder"]],["bool"]]],[11,"ne","","",16,[[["self"],["encoder"]],["bool"]]],[11,"eq","","",17,[[["self"],["decoder"]],["bool"]]],[11,"ne","","",17,[[["self"],["decoder"]],["bool"]]],[11,"eq","","",0,[[["self"],["message"]],["bool"]]],[11,"ne","","",0,[[["self"],["message"]],["bool"]]],[11,"eq","","",1,[[["self"],["wire"]],["bool"]]],[11,"ne","","",1,[[["self"],["wire"]],["bool"]]],[11,"from","fancy_garbling::error","",11,[[["syncerror"]],["garblererror"]]],[11,"from","","",10,[[["syncerror"]],["evaluatorerror"]]],[11,"from","","",9,[[["syncerror"]],["dummyerror"]]],[11,"from","","",7,[[["dummyerror"]],["fancyerror",["dummyerror"]]]],[11,"from","","",7,[[["evaluatorerror"]],["fancyerror",["evaluatorerror"]]]],[11,"from","","",7,[[["garblererror"]],["fancyerror",["garblererror"]]]],[11,"from","","",7,[[["circuitbuildererror"]],["fancyerror",["circuitbuildererror"]]]],[11,"from","","",7,[[["informererror"]],["fancyerror",["informererror"]]]],[11,"from","","",12,[[["error"]],["circuitparsererror"]]],[11,"from","","",12,[[["error"]],["circuitparsererror"]]],[11,"from","","",12,[[["parseinterror"]],["circuitparsererror"]]],[11,"from","","",7,[[["circuitparsererror"]],["fancyerror",["circuitparsererror"]]]],[11,"clone","fancy_garbling::circuit","",2,[[["self"]],["circuitref"]]],[11,"clone","","",3,[[["self"]],["circuit"]]],[11,"clone","","",4,[[["self"]],["gate"]]],[11,"clone","fancy_garbling::dummy","",24,[[["self"]],["dummyval"]]],[11,"clone","fancy_garbling","",13,[[["self"]],["bundle"]]],[11,"clone","","",0,[[["self"]],["message"]]],[11,"clone","fancy_garbling::informer","",27,[[["self"]],["informerval"]]],[11,"clone","fancy_garbling","",1,[[["self"]],["wire"]]],[11,"fmt","fancy_garbling::circuit","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling::error","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling::circuit","",2,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",3,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",4,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling::dummy","",24,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling::error","",7,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",8,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",9,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",10,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",11,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",25,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",26,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",12,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling","",15,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",16,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",17,[[["self"],["formatter"]],["result"]]],[11,"fmt","","",0,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling::informer","",27,[[["self"],["formatter"]],["result"]]],[11,"fmt","fancy_garbling","",1,[[["self"],["formatter"]],["result"]]],[11,"serialize","fancy_garbling::circuit","",2,[[["self"],["__s"]],["result"]]],[11,"serialize","","",3,[[["self"],["__s"]],["result"]]],[11,"serialize","","",4,[[["self"],["__s"]],["result"]]],[11,"serialize","fancy_garbling","",15,[[["self"],["__s"]],["result"]]],[11,"serialize","","",16,[[["self"],["__s"]],["result"]]],[11,"serialize","","",17,[[["self"],["__s"]],["result"]]],[11,"serialize","","",0,[[["self"],["__s"]],["result"]]],[11,"serialize","","",1,[[["self"],["__s"]],["result"]]],[11,"deserialize","fancy_garbling::circuit","",2,[[["__d"]],["result"]]],[11,"deserialize","","",3,[[["__d"]],["result"]]],[11,"deserialize","","",4,[[["__d"]],["result"]]],[11,"deserialize","fancy_garbling","",15,[[["__d"]],["result"]]],[11,"deserialize","","",16,[[["__d"]],["result"]]],[11,"deserialize","","",17,[[["__d"]],["result"]]],[11,"deserialize","","",0,[[["__d"]],["result"]]],[11,"deserialize","","",1,[[["__d"]],["result"]]],[11,"garbler_input_bundle","","Crate an input bundle for the garbler using moduli `ps` and optional inputs `xs`.",21,N],[11,"evaluator_input_bundle","","Crate an input bundle for the evaluator using moduli `ps`.",21,N],[11,"garbler_input_bundle_crt","","Crate an input bundle for the garbler using composite CRT modulus `q` and optional input `x`.",21,[[["self"],["option",["syncindex"]],["u128"],["option",["u128"]]],["result",["bundle","fancyerror"]]]],[11,"evaluator_input_bundle_crt","","Crate an input bundle for the evaluator using composite CRT modulus `q`.",21,[[["self"],["option",["syncindex"]],["u128"]],["result",["bundle","fancyerror"]]]],[11,"garbler_input_bundle_binary","","Create an input bundle for the garbler using `nbits` base 2 inputs and optional input `x`.",21,[[["self"],["option",["syncindex"]],["usize"],["option",["u128"]]],["result",["bundle","fancyerror"]]]],[11,"evaluator_input_bundle_binary","","Create an input bundle for the evaluator using n base 2 inputs.",21,[[["self"],["option",["syncindex"]],["usize"]],["result",["bundle","fancyerror"]]]],[11,"constant_bundle","","Creates a bundle of constant wires using moduli `ps`.",21,N],[11,"constant_bundle_crt","","Creates a bundle of constant wires for the CRT representation of `x` under composite modulus `q`.",21,[[["self"],["option",["syncindex"]],["u128"],["u128"]],["result",["bundle","fancyerror"]]]],[11,"constant_bundle_binary","","Create a constant bundle using base 2 inputs.",21,[[["self"],["option",["syncindex"]],["u128"],["usize"]],["result",["bundle","fancyerror"]]]],[11,"garbler_input_bundles","","Create `n` garbler input bundles, using moduli `ps` and optional inputs `xs`.",21,N],[11,"evaluator_input_bundles","","Create `n` evaluator input bundles, using moduli `ps`.",21,N],[11,"garbler_input_bundles_crt","","Create `n` garbler input bundles, under composite CRT modulus `q` and optional inputs `xs`.",21,[[["self"],["option",["syncindex"]],["u128"],["usize"],["option",["vec"]]],["result",["vec","fancyerror"]]]],[11,"evaluator_input_bundles_crt","","Create `n` evaluator input bundles, under composite CRT modulus `q`.",21,[[["self"],["option",["syncindex"]],["u128"],["usize"]],["result",["vec","fancyerror"]]]],[11,"output_bundle","","Output the wires that make up a bundle.",21,[[["self"],["option",["syncindex"]],["bundle"]],["result",["fancyerror"]]]],[11,"output_bundles","","Output a slice of bundles.",21,N],[11,"add_bundles","","Add two wire bundles, residue by residue.",21,[[["self"],["bundle"],["bundle"]],["result",["bundle","fancyerror"]]]],[11,"sub_bundles","","Subtract two wire bundles, residue by residue.",21,[[["self"],["bundle"],["bundle"]],["result",["bundle","fancyerror"]]]],[11,"cmul_bundle","","Multiplies each wire in `x` by the corresponding residue of `c`.",21,[[["self"],["bundle"],["u128"]],["result",["bundle","fancyerror"]]]],[11,"mul_bundles","","Multiply `x` with `y`.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"]],["result",["bundle","fancyerror"]]]],[11,"cexp_bundle","","Exponentiate `x` by the constant `c`.",21,[[["self"],["option",["syncindex"]],["bundle"],["u16"]],["result",["bundle","fancyerror"]]]],[11,"rem_bundle","","Compute the remainder with respect to modulus `p`.",21,[[["self"],["option",["syncindex"]],["bundle"],["u16"]],["result",["bundle","fancyerror"]]]],[11,"eq_bundles","","Compute `x == y`. Returns a wire encoding the result mod 2.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"]],["result",["fancyerror"]]]],[11,"mixed_radix_addition","","Mixed radix addition.",21,N],[11,"mixed_radix_addition_msb_only","","Mixed radix addition only returning the MSB.",21,N],[11,"fractional_mixed_radix","","Helper function for advanced gadgets, returns the MSB of the fractional part of `X/M` where `M=product(ms)`.",21,N],[11,"relu","","Compute `max(x,0)`.",21,[[["self"],["option",["syncindex"]],["bundle"],["str"],["option"]],["result",["bundle","fancyerror"]]]],[11,"sign","","Return 0 if `x` is positive and 1 if `x` is negative.",21,[[["self"],["option",["syncindex"]],["bundle"],["str"]],["result",["fancyerror"]]]],[11,"sgn","","Return `if x >= 0 then 1 else -1`, where `-1` is interpreted as `Q-1`.",21,[[["self"],["option",["syncindex"]],["bundle"],["str"],["option"]],["result",["bundle","fancyerror"]]]],[11,"lt","","Returns 1 if `x < y`. Works on both CRT and binary bundles.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"],["str"]],["result",["fancyerror"]]]],[11,"geq","","Returns 1 if `x >= y`. Works on both CRT and binary bundles.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"],["str"]],["result",["fancyerror"]]]],[11,"max","","Compute the maximum bundle in `xs`.",21,N],[11,"binary_addition","","Binary addition. Returns the result and the carry.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"]],["result",["fancyerror"]]]],[11,"binary_addition_no_carry","","Binary addition. Avoids creating extra gates for the final carry.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"]],["result",["bundle","fancyerror"]]]],[11,"binary_multiplication_lower_half","","Binary multiplication.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"]],["result",["bundle","fancyerror"]]]],[11,"twos_complement","","Compute the twos complement of the input bundle (which must be base 2).",21,[[["self"],["option",["syncindex"]],["bundle"]],["result",["bundle","fancyerror"]]]],[11,"binary_subtraction","","Subtract two binary bundles. Returns the result and whether it underflowed.",21,[[["self"],["option",["syncindex"]],["bundle"],["bundle"]],["result",["fancyerror"]]]],[11,"multiplex","","If b=0 then return x, else return y.",21,N],[11,"multiplex_constant_bits","","If `x=0` return `c1` as a bundle of constant bits, else return `c2`.",21,N],[11,"shift","","Shift residues, replacing them with zeros in the modulus of the least signifigant residue.",21,[[["self"],["option",["syncindex"]],["bundle"],["usize"]],["result",["bundle","fancyerror"]]]],[11,"binary_cmul","","Write the constant in binary and that gives you the shift amounts, Eg.. 7x is 4x+2x+x.",21,[[["self"],["option",["syncindex"]],["bundle"],["u128"],["usize"]],["result",["bundle","fancyerror"]]]],[11,"abs","","Compute the absolute value of a binary bundle.",21,[[["self"],["option",["syncindex"]],["bundle"]],["result",["bundle","fancyerror"]]]],[11,"begin_sync","","Start synchronization of internal messages.",23,[[["self"],["syncindex"]],["result",["fancyerror"]]]],[11,"finish_index","","Declare this index to be done.",23,[[["self"],["syncindex"]],["result",["fancyerror"]]]],[11,"garbler_inputs","","Create `n` garbler inputs with the moduli `qs` and optional inputs `xs`.",23,N],[11,"evaluator_inputs","","Create `n` evaluator inputs with the moduli `qs`.",23,N],[11,"add_many","","Sum up a slice of wires.",23,N],[11,"xor","","Xor is just addition, with the requirement that `x` and `y` are mod 2.",23,N],[11,"negate","","Negate by xoring `x` with `1`.",23,N],[11,"and","","And is just multiplication, with the requirement that `x` and `y` are mod 2.",23,N],[11,"or","","Or uses Demorgan's Rule implemented with multiplication and negation.",23,N],[11,"and_many","","Returns 1 if all wires equal 1.",23,N],[11,"or_many","","Returns 1 if any wire equals 1.",23,N],[11,"mod_change","","Change the modulus of `x` to `to_modulus` using a projection gate.",23,N],[11,"adder","","Binary adder. Returns the result and the carry.",23,N],[11,"mux","","If `b=0` returns `x` else `y`.",23,N],[11,"mux_constant_bits","","If `x=0` return the constant `b1` else return `b2`. Folds constants if possible.",23,N],[11,"outputs","","Output a slice of wires.",23,N]],"paths":[[4,"Message"],[4,"Wire"],[3,"CircuitRef"],[3,"Circuit"],[4,"Gate"],[3,"CircuitBuilder"],[3,"Dummy"],[4,"FancyError"],[4,"SyncError"],[4,"DummyError"],[4,"EvaluatorError"],[4,"GarblerError"],[4,"CircuitParserError"],[3,"Bundle"],[3,"Evaluator"],[3,"GarbledCircuit"],[3,"Encoder"],[3,"Decoder"],[3,"Garbler"],[3,"Informer"],[8,"RngExt"],[8,"BundleGadgets"],[8,"HasModulus"],[8,"Fancy"],[3,"DummyVal"],[3,"CircuitBuilderError"],[3,"InformerError"],[3,"InformerVal"]]};
initSearch(searchIndex);
